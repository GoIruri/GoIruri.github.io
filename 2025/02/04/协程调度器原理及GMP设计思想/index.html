<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Golang的协程调度器原理及GMP设计思想 | igl1t's blog</title><meta name="author" content="igl1t"><meta name="copyright" content="igl1t"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Golang的协程调度器原理及GMP设计思想一、Golang“调度器”的由来？(1) 单进程时代不需要调度器我们知道，一切的软件都是跑在操作系统上，真正用来干活(计算)的是CPU。早期的操作系统每个程序就是一个进程，直到一个程序运行完，才能进行下一个进程，就是“单进程时代” 一切的程序只能串行发生。 早期的单进程操作系统，面临2个问题： 1.单一的执行流程，计算机只能一个任务一个任务处理。 2.进">
<meta property="og:type" content="article">
<meta property="og:title" content="Golang的协程调度器原理及GMP设计思想">
<meta property="og:url" content="http://example.com/2025/02/04/%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%99%A8%E5%8E%9F%E7%90%86%E5%8F%8AGMP%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/index.html">
<meta property="og:site_name" content="igl1t&#39;s blog">
<meta property="og:description" content="Golang的协程调度器原理及GMP设计思想一、Golang“调度器”的由来？(1) 单进程时代不需要调度器我们知道，一切的软件都是跑在操作系统上，真正用来干活(计算)的是CPU。早期的操作系统每个程序就是一个进程，直到一个程序运行完，才能进行下一个进程，就是“单进程时代” 一切的程序只能串行发生。 早期的单进程操作系统，面临2个问题： 1.单一的执行流程，计算机只能一个任务一个任务处理。 2.进">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/butterfly-icon.png">
<meta property="article:published_time" content="2025-02-04T12:52:00.028Z">
<meta property="article:modified_time" content="2025-02-04T07:46:22.000Z">
<meta property="article:author" content="igl1t">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Golang的协程调度器原理及GMP设计思想",
  "url": "http://example.com/2025/02/04/%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%99%A8%E5%8E%9F%E7%90%86%E5%8F%8AGMP%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/",
  "image": "http://example.com/img/butterfly-icon.png",
  "datePublished": "2025-02-04T12:52:00.028Z",
  "dateModified": "2025-02-04T07:46:22.000Z",
  "author": [
    {
      "@type": "Person",
      "name": "igl1t",
      "url": "http://example.com/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2025/02/04/%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%99%A8%E5%8E%9F%E7%90%86%E5%8F%8AGMP%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Golang的协程调度器原理及GMP设计思想',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(/img/back.png);"></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/back.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">igl1t's blog</span></a><a class="nav-page-title" href="/"><span class="site-name">Golang的协程调度器原理及GMP设计思想</span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">Golang的协程调度器原理及GMP设计思想</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-02-04T12:52:00.028Z" title="发表于 2025-02-04 20:52:00">2025-02-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-02-04T07:46:22.000Z" title="更新于 2025-02-04 15:46:22">2025-02-04</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="Golang的协程调度器原理及GMP设计思想"><a href="#Golang的协程调度器原理及GMP设计思想" class="headerlink" title="Golang的协程调度器原理及GMP设计思想"></a><font style="color:rgb(51, 51, 51);">Golang的协程调度器原理及GMP设计思想</font></h1><h4 id="一、Golang“调度器”的由来？"><a href="#一、Golang“调度器”的由来？" class="headerlink" title="一、Golang“调度器”的由来？"></a><font style="color:rgb(51, 51, 51);">一、Golang“调度器”的由来？</font></h4><h5 id="1-单进程时代不需要调度器"><a href="#1-单进程时代不需要调度器" class="headerlink" title="(1) 单进程时代不需要调度器"></a><font style="color:rgb(51, 51, 51);">(1) 单进程时代不需要调度器</font></h5><p><font style="color:rgb(51, 51, 51);">我们知道，一切的软件都是跑在操作系统上，真正用来干活(计算)的是CPU。早期的操作系统每个程序就是一个进程，直到一个程序运行完，才能进行下一个进程，就是“单进程时代”</font></p>
<p><font style="color:rgb(51, 51, 51);">一切的程序只能串行发生。</font><img src="https://cdn.nlark.com/yuque/0/2023/png/29334239/1683529375752-8196ceae-bd91-4ef3-b303-db89aecaf312.png"></p>
<p><font style="color:rgb(51, 51, 51);">早期的单进程操作系统，面临2个问题：</font></p>
<p><font style="color:rgb(51, 51, 51);">1.单一的执行流程，计算机只能一个任务一个任务处理。</font></p>
<p><font style="color:rgb(51, 51, 51);">2.进程阻塞所带来的CPU时间浪费。</font></p>
<p><font style="color:rgb(51, 51, 51);">那么能不能有多个进程来宏观一起来执行多个任务呢？</font></p>
<p><font style="color:rgb(51, 51, 51);">后来操作系统就具有了</font><strong><font style="color:rgb(51, 51, 51);">最早的并发能力：多进程并发</font></strong><font style="color:rgb(51, 51, 51);">，当一个进程阻塞的时候，切换到另外等待执行的进程，这样就能尽量把CPU利用起来，CPU就不浪费了。</font></p>
<h5 id="2-多进程-线程时代有了调度器需求"><a href="#2-多进程-线程时代有了调度器需求" class="headerlink" title="(2)多进程&#x2F;线程时代有了调度器需求"></a><font style="color:rgb(51, 51, 51);">(2)多进程&#x2F;线程时代有了调度器需求</font></h5><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29334239/1683529375730-5e191a9b-f141-4365-a41c-84e6b6491bc9.png"></p>
<p><font style="color:rgb(51, 51, 51);">在多进程&#x2F;多线程的操作系统中，就解决了阻塞的问题，因为一个进程阻塞cpu可以立刻切换到其他进程中去执行，而且调度cpu的算法可以保证在运行的进程都可以被分配到cpu的运行时间片。这样从宏观来看，似乎多个进程是在同时被运行。</font></p>
<p><font style="color:rgb(51, 51, 51);">但新的问题就又出现了，进程拥有太多的资源，进程的创建、切换、销毁，都会占用很长的时间，CPU虽然利用起来了，但如果进程过多，CPU有很大的一部分都被用来进行进程调度了。</font></p>
<p><strong><font style="color:rgb(51, 51, 51);">怎么才能提高CPU的利用率呢？</font></strong></p>
<p><font style="color:rgb(51, 51, 51);">但是对于Linux操作系统来讲，cpu对进程的态度和线程的态度是一样的。</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29334239/1683529375726-397d9665-c642-4cde-a5b1-c52c15892058.png"></p>
<p><font style="color:rgb(51, 51, 51);">很明显，CPU调度切换的是进程和线程。尽管线程看起来很美好，但实际上多线程开发设计会变得更加复杂，要考虑很多同步竞争等问题，如锁、竞争冲突等。</font></p>
<h5 id="3-协程来提高CPU利用率"><a href="#3-协程来提高CPU利用率" class="headerlink" title="(3)协程来提高CPU利用率"></a><font style="color:rgb(51, 51, 51);">(3)协程来提高CPU利用率</font></h5><p><font style="color:rgb(51, 51, 51);">多进程、多线程已经提高了系统的并发能力，但是在当今互联网高并发场景下，为每个任务都创建一个线程是不现实的，因为会消耗大量的内存(进程虚拟内存会占用4GB[32位操作系统], 而线程也要大约4MB)。</font></p>
<p><font style="color:rgb(51, 51, 51);">大量的进程&#x2F;线程出现了新的问题</font></p>
<ul>
<li><font style="color:rgb(51, 51, 51);">高内存占用</font></li>
<li><font style="color:rgb(51, 51, 51);">调度的高消耗CPU</font></li>
</ul>
<p><font style="color:rgb(51, 51, 51);">好了，然后工程师们就发现，其实一个线程分为“内核态“线程和”用户态“线程。</font></p>
<p><font style="color:rgb(51, 51, 51);">一个“用户态线程”必须要绑定一个“内核态线程”，但是CPU并不知道有“用户态线程”的存在，它只知道它运行的是一个“内核态线程”(Linux的PCB进程控制块)。</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29334239/1683529375735-e418073f-83bb-4836-84de-271eda59381e.png"></p>
<p><font style="color:rgb(51, 51, 51);">这样，我们再去细化去分类一下，内核线程依然叫“线程(thread)”，用户线程叫“协程(co-routine)”.</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29334239/1683529375860-cf66be10-e020-4707-b721-43a8ba16a163.png"></p>
<p><font style="color:rgb(51, 51, 51);">看到这里，我们就要开脑洞了，既然一个协程(co-routine)可以绑定一个线程(thread)，那么能不能多个协程(co-routine)绑定一个或者多个线程(thread)上呢。</font></p>
<p><font style="color:rgb(51, 51, 51);">之后，我们就看到了有3中协程和线程的映射关系：</font></p>
<h4 id="N-1关系"><a href="#N-1关系" class="headerlink" title="N:1关系"></a><font style="color:rgb(119, 119, 119);">N:1关系</font></h4><p><font style="color:rgb(51, 51, 51);">N个协程绑定1个线程，优点就是</font><strong><font style="color:rgb(51, 51, 51);">协程在用户态线程即完成切换，不会陷入到内核态，这种切换非常的轻量快速</font></strong><font style="color:rgb(51, 51, 51);">。但也有很大的缺点，1个进程的所有协程都绑定在1个线程上</font></p>
<p><font style="color:rgb(51, 51, 51);">缺点：</font></p>
<ul>
<li><font style="color:rgb(51, 51, 51);">某个程序用不了硬件的多核加速能力</font></li>
<li><font style="color:rgb(51, 51, 51);">一旦某协程阻塞，造成线程阻塞，本进程的其他协程都无法执行了，根本就没有并发的能力了。</font></li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29334239/1683529376831-20991e4f-318e-4351-95d4-2ef497dc25a0.png"></p>
<h4 id="1-1-关系"><a href="#1-1-关系" class="headerlink" title="1:1 关系"></a><font style="color:rgb(119, 119, 119);">1:1 关系</font></h4><p><font style="color:rgb(51, 51, 51);">1个协程绑定1个线程，这种最容易实现。协程的调度都由CPU完成了，不存在N:1缺点，</font></p>
<p><font style="color:rgb(51, 51, 51);">缺点：</font></p>
<ul>
<li><font style="color:rgb(51, 51, 51);">协程的创建、删除和切换的代价都由CPU完成，有点略显昂贵了。</font></li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29334239/1683529376891-9ec932ae-7643-468d-9e5e-8c9a9c79f3ab.png"></p>
<h4 id="M-N关系"><a href="#M-N关系" class="headerlink" title="M:N关系"></a><font style="color:rgb(119, 119, 119);">M:N关系</font></h4><p><font style="color:rgb(51, 51, 51);">M个协程绑定1个线程，是N:1和1:1类型的结合，克服了以上2种模型的缺点，但实现起来最为复杂。</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29334239/1683529377178-d7a47abb-d2dd-4904-ae6c-ab6416543a0f.png"></p>
<p><font style="color:rgb(51, 51, 51);">协程跟线程是有区别的，线程由CPU调度是抢占式的，</font><strong><font style="color:rgb(51, 51, 51);">协程由用户态调度是协作式的</font></strong><font style="color:rgb(51, 51, 51);">，一个协程让出CPU后，才执行下一个协程。</font></p>
<h5 id="4-Go语言的协程goroutine"><a href="#4-Go语言的协程goroutine" class="headerlink" title="(4)Go语言的协程goroutine"></a><font style="color:rgb(51, 51, 51);">(4)Go语言的协程goroutine</font></h5><p><strong><font style="color:rgb(51, 51, 51);">Go为了提供更容易使用的并发方法，使用了goroutine和channel</font></strong><font style="color:rgb(51, 51, 51);">。goroutine来自协程的概念，让一组可复用的函数运行在一组线程之上，即使有协程阻塞，该线程的其他协程也可以被</font><font style="color:rgb(51, 51, 51);background-color:rgb(243, 244, 244);">runtime</font><font style="color:rgb(51, 51, 51);">调度，转移到其他可运行的线程上。最关键的是，程序员看不到这些底层的细节，这就降低了编程的难度，提供了更容易的并发。</font></p>
<p><font style="color:rgb(51, 51, 51);">Go中，协程被称为goroutine，它非常轻量，一个goroutine只占几KB，并且这几KB就足够goroutine运行完，这就能在有限的内存空间内支持大量goroutine，支持了更多的并发。虽然一个goroutine的栈只占几KB，但实际是可伸缩的，如果需要更多内容，</font><font style="color:rgb(51, 51, 51);background-color:rgb(243, 244, 244);">runtime</font><font style="color:rgb(51, 51, 51);">会自动为goroutine分配。</font></p>
<p><font style="color:rgb(51, 51, 51);">Goroutine特点：</font></p>
<ul>
<li><font style="color:rgb(51, 51, 51);">占用内存更小（几kb）</font></li>
<li><font style="color:rgb(51, 51, 51);">调度更灵活(runtime调度)</font></li>
</ul>
<h5 id="5-被废弃的goroutine调度器"><a href="#5-被废弃的goroutine调度器" class="headerlink" title="(5)被废弃的goroutine调度器"></a><font style="color:rgb(51, 51, 51);">(5)被废弃的goroutine调度器</font></h5><p><font style="color:rgb(51, 51, 51);">好了，既然我们知道了协程和线程的关系，那么最关键的一点就是调度协程的调度器的实现了。</font></p>
<p><font style="color:rgb(51, 51, 51);">Go目前使用的调度器是2012年重新设计的，因为之前的调度器性能存在问题，所以使用4年就被废弃了，那么我们先来分析一下被废弃的调度器是如何运作的？</font></p>
<p><font style="color:rgb(119, 119, 119);">大部分文章都是会用G来表示Goroutine，用M来表示线程，那么我们也会用这种表达的对应关系。</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29334239/1683529377162-1a068acc-a631-4de2-9ea4-f62957e6f5cd.png"></p>
<p><font style="color:rgb(51, 51, 51);">下面我们来看看被废弃的golang调度器是如何实现的？</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29334239/1683529377192-b619ad81-84c2-4171-85af-48c38152c594.png"></p>
<p><font style="color:rgb(51, 51, 51);">M想要执行、放回G都必须访问全局G队列，并且M有多个，即多线程访问同一资源需要加锁进行保证互斥&#x2F;同步，所以全局G队列是有互斥锁进行保护的。</font></p>
<p><font style="color:rgb(51, 51, 51);">老调度器有几个缺点：</font></p>
<ol>
<li><font style="color:rgb(51, 51, 51);">创建、销毁、调度G都需要每个M获取锁，这就形成了</font><strong><font style="color:rgb(51, 51, 51);">激烈的锁竞争</font></strong><font style="color:rgb(51, 51, 51);">。</font></li>
<li><font style="color:rgb(51, 51, 51);">M转移G会造成</font><strong><font style="color:rgb(51, 51, 51);">延迟和额外的系统负载</font></strong><font style="color:rgb(51, 51, 51);">。比如当G中包含创建新协程的时候，M创建了G’，为了继续执行G，需要把G’交给M’执行，也造成了</font><strong><font style="color:rgb(51, 51, 51);">很差的局部性</font></strong><font style="color:rgb(51, 51, 51);">，因为G’和G是相关的，最好放在M上执行，而不是其他M’。</font></li>
<li><font style="color:rgb(51, 51, 51);">系统调用(CPU在M之间的切换)导致频繁的线程阻塞和取消阻塞操作增加了系统开销。</font></li>
</ol>
<h4 id="二、Goroutine调度器的GMP模型的设计思想"><a href="#二、Goroutine调度器的GMP模型的设计思想" class="headerlink" title="二、Goroutine调度器的GMP模型的设计思想"></a><font style="color:rgb(51, 51, 51);">二、Goroutine调度器的GMP模型的设计思想</font></h4><p><font style="color:rgb(51, 51, 51);">面对之前调度器的问题，Go设计了新的调度器。</font></p>
<p><font style="color:rgb(51, 51, 51);">在新调度器中，除了M(thread)和G(goroutine)，又引进了P(Processor)。</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29334239/1683529378065-00b6c082-caec-426d-a71c-0bb68f5256a4.png"></p>
<p><strong><font style="color:rgb(51, 51, 51);">Processor，它包含了运行goroutine的资源</font></strong><font style="color:rgb(51, 51, 51);">，如果线程想运行goroutine，必须先获取P，P中还包含了可运行的G队列。</font></p>
<h5 id="1-GMP模型"><a href="#1-GMP模型" class="headerlink" title="(1)GMP模型"></a><font style="color:rgb(51, 51, 51);">(1)GMP模型</font></h5><p><font style="color:rgb(51, 51, 51);">在Go中，</font><strong><font style="color:rgb(51, 51, 51);">线程是运行goroutine的实体，调度器的功能是把可运行的goroutine分配到工作线程上</font></strong><font style="color:rgb(51, 51, 51);">。</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29334239/1683529378267-57367699-0d00-4929-9f88-bb2fb96a69b7.png"></p>
<ol>
<li><strong><font style="color:rgb(51, 51, 51);">全局队列</font></strong><font style="color:rgb(51, 51, 51);">（Global Queue）：存放等待运行的G。</font></li>
<li><strong><font style="color:rgb(51, 51, 51);">P的本地队列</font></strong><font style="color:rgb(51, 51, 51);">：同全局队列类似，存放的也是等待运行的G，存的数量有限，不超过256个。新建G’时，G’优先加入到P的本地队列，如果队列满了，则会把本地队列中一半的G移动到全局队列。</font></li>
<li><strong><font style="color:rgb(51, 51, 51);">P列表</font></strong><font style="color:rgb(51, 51, 51);">：所有的P都在程序启动时创建，并保存在数组中，最多有</font><font style="color:rgb(51, 51, 51);background-color:rgb(243, 244, 244);">GOMAXPROCS</font><font style="color:rgb(51, 51, 51);">(可配置)个。</font></li>
<li><strong><font style="color:rgb(51, 51, 51);">M</font></strong><font style="color:rgb(51, 51, 51);">：线程想运行任务就得获取P，从P的本地队列获取G，P队列为空时，M也会尝试从全局队列</font><strong><font style="color:rgb(51, 51, 51);">拿</font></strong><font style="color:rgb(51, 51, 51);">一批G放到P的本地队列，或从其他P的本地队列</font><strong><font style="color:rgb(51, 51, 51);">偷</font></strong><font style="color:rgb(51, 51, 51);">一半放到自己P的本地队列。M运行G，G执行之后，M会从P获取下一个G，不断重复下去。</font></li>
</ol>
<p><strong><font style="color:rgb(51, 51, 51);">Goroutine调度器和OS调度器是通过M结合起来的，每个M都代表了1个内核线程，OS调度器负责把内核线程分配到CPU的核上执行</font></strong><font style="color:rgb(51, 51, 51);">。</font></p>
<h3 id="有关P和M的个数问题"><a href="#有关P和M的个数问题" class="headerlink" title="有关P和M的个数问题"></a><font style="color:rgb(119, 119, 119);">有关P和M的个数问题</font></h3><p><font style="color:rgb(51, 51, 51);">1、P的数量：</font></p>
<ul>
<li><font style="color:rgb(51, 51, 51);">由启动时环境变量</font><font style="color:rgb(51, 51, 51);background-color:rgb(243, 244, 244);">$GOMAXPROCS</font><font style="color:rgb(51, 51, 51);">或者是由</font><font style="color:rgb(51, 51, 51);background-color:rgb(243, 244, 244);">runtime</font><font style="color:rgb(51, 51, 51);">的方法</font><font style="color:rgb(51, 51, 51);background-color:rgb(243, 244, 244);">GOMAXPROCS()</font><font style="color:rgb(51, 51, 51);">决定。这意味着在程序执行的任意时刻都只有</font><font style="color:rgb(51, 51, 51);background-color:rgb(243, 244, 244);">$GOMAXPROCS</font><font style="color:rgb(51, 51, 51);">个goroutine在同时运行。</font></li>
</ul>
<p><font style="color:rgb(51, 51, 51);">2、M的数量:</font></p>
<ul>
<li><font style="color:rgb(51, 51, 51);">go语言本身的限制：go程序启动时，会设置M的最大数量，默认10000.但是内核很难支持这么多的线程数，所以这个限制可以忽略。</font></li>
<li><font style="color:rgb(51, 51, 51);">runtime&#x2F;debug中的SetMaxThreads函数，设置M的最大数量</font></li>
<li><font style="color:rgb(51, 51, 51);">一个M阻塞了，会创建新的M。</font></li>
</ul>
<p><font style="color:rgb(51, 51, 51);">M与P的数量没有绝对关系，一个M阻塞，P就会去创建或者切换另一个M，所以，即使P的默认数量是1，也有可能会创建很多个M出来。</font></p>
<h3 id="P和M何时会被创建"><a href="#P和M何时会被创建" class="headerlink" title="P和M何时会被创建"></a><font style="color:rgb(119, 119, 119);">P和M何时会被创建</font></h3><p><font style="color:rgb(51, 51, 51);">1、P何时创建：在确定了P的最大数量n后，运行时系统会根据这个数量创建n个P。</font></p>
<p><font style="color:rgb(51, 51, 51);">2、M何时创建：没有足够的M来关联P并运行其中的可运行的G。比如所有的M此时都阻塞住了，而P中还有很多就绪任务，就会去寻找空闲的M，而没有空闲的，就会去创建新的M。</font></p>
<h5 id="2-调度器的设计策略"><a href="#2-调度器的设计策略" class="headerlink" title="(2)调度器的设计策略"></a><font style="color:rgb(51, 51, 51);">(2)调度器的设计策略</font></h5><p><strong><font style="color:rgb(51, 51, 51);">复用线程</font></strong><font style="color:rgb(51, 51, 51);">：避免频繁的创建、销毁线程，而是对线程的复用。</font></p>
<p><font style="color:rgb(51, 51, 51);">1）work stealing机制</font></p>
<p><font style="color:rgb(51, 51, 51);">当本线程无可运行的G时，尝试从其他线程绑定的P偷取G，而不是销毁线程。</font></p>
<p><font style="color:rgb(51, 51, 51);">2）hand off机制</font></p>
<p><font style="color:rgb(51, 51, 51);">当本线程因为G进行系统调用阻塞时，线程释放绑定的P，把P转移给其他空闲的线程执行。</font></p>
<p><strong><font style="color:rgb(51, 51, 51);">利用并行</font></strong><font style="color:rgb(51, 51, 51);">：</font><font style="color:rgb(51, 51, 51);background-color:rgb(243, 244, 244);">GOMAXPROCS</font><font style="color:rgb(51, 51, 51);">设置P的数量，最多有</font><font style="color:rgb(51, 51, 51);background-color:rgb(243, 244, 244);">GOMAXPROCS</font><font style="color:rgb(51, 51, 51);">个线程分布在多个CPU上同时运行。</font><font style="color:rgb(51, 51, 51);background-color:rgb(243, 244, 244);">GOMAXPROCS</font><font style="color:rgb(51, 51, 51);">也限制了并发的程度，比如</font><font style="color:rgb(51, 51, 51);background-color:rgb(243, 244, 244);">GOMAXPROCS &#x3D; 核数&#x2F;2</font><font style="color:rgb(51, 51, 51);">，则最多利用了一半的CPU核进行并行。</font></p>
<p><strong><font style="color:rgb(51, 51, 51);">抢占</font></strong><font style="color:rgb(51, 51, 51);">：在coroutine中要等待一个协程主动让出CPU才执行下一个协程，在Go中，一个goroutine最多占用CPU 10ms，防止其他goroutine被饿死，这就是goroutine不同于coroutine的一个地方。</font></p>
<p><strong><font style="color:rgb(51, 51, 51);">全局G队列</font></strong><font style="color:rgb(51, 51, 51);">：在新的调度器中依然有全局G队列，但功能已经被弱化了，当M执行work stealing从其他P偷不到G时，它可以从全局G队列获取G。</font></p>
<h5 id="3-go-func-调度流程"><a href="#3-go-func-调度流程" class="headerlink" title="(3) go func() 调度流程"></a><font style="color:rgb(51, 51, 51);">(3) go func() 调度流程</font></h5><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29334239/1683529378457-957dc494-148b-4632-bf7f-2a9f8f4cb7a9.png"></p>
<p><font style="color:rgb(51, 51, 51);">从上图我们可以分析出几个结论：</font></p>
<p><font style="color:rgb(51, 51, 51);">1、我们通过 go func()来创建一个goroutine；</font></p>
<p><font style="color:rgb(51, 51, 51);">2、有两个存储G的队列，一个是局部调度器P的本地队列、一个是全局G队列。新创建的G会先保存在P的本地队列中，如果P的本地队列已经满了就会保存在全局的队列中；</font></p>
<p><font style="color:rgb(51, 51, 51);">3、G只能运行在M中，一个M必须持有一个P，M与P是1：1的关系。M会从P的本地队列弹出一个可执行状态的G来执行，如果P的本地队列为空，就会想其他的MP组合偷取一个可执行的G来执行；</font></p>
<p><font style="color:rgb(51, 51, 51);">4、一个M调度G执行的过程是一个循环机制；</font></p>
<p><font style="color:rgb(51, 51, 51);">5、当M执行某一个G时候如果发生了syscall或则其余阻塞操作，M会阻塞，如果当前有一些G在执行，runtime会把这个线程M从P中摘除(detach)，然后再创建一个新的操作系统的线程(如果有空闲的线程可用就复用空闲线程)来服务于这个P；</font></p>
<p><font style="color:rgb(51, 51, 51);">6、当M系统调用结束时候，这个G会尝试获取一个空闲的P执行，并放入到这个P的本地队列。如果获取不到P，那么这个线程M变成休眠状态， 加入到空闲线程中，然后这个G会被放入全局队列中。</font></p>
<h5 id="4-调度器的生命周期"><a href="#4-调度器的生命周期" class="headerlink" title="(4)调度器的生命周期"></a><font style="color:rgb(51, 51, 51);">(4)调度器的生命周期</font></h5><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29334239/1683529378443-5959b5ce-2f9d-4ea9-a1e9-af8b4d07f818.png"></p>
<p><font style="color:rgb(51, 51, 51);">特殊的M0和G0</font></p>
<p><strong><font style="color:rgb(51, 51, 51);">M0</font></strong></p>
<p><font style="color:rgb(51, 51, 51);background-color:rgb(243, 244, 244);">M0</font><font style="color:rgb(51, 51, 51);">是启动程序后的编号为0的主线程，这个M对应的实例会在全局变量runtime.m0中，不需要在heap上分配，M0负责执行初始化操作和启动第一个G， 在之后M0就和其他的M一样了。</font></p>
<p><strong><font style="color:rgb(51, 51, 51);">G0</font></strong></p>
<p><font style="color:rgb(51, 51, 51);background-color:rgb(243, 244, 244);">G0</font><font style="color:rgb(51, 51, 51);">是每次启动一个M都会第一个创建的 goroutine，G0仅用于负责调度的G，G0不指向任何可执行的函数, 每个M都会有一个自己的G0。在调度或系统调用时会使用G0的栈空间, 全局变量的G0是M0的G0。</font></p>
<p><font style="color:rgb(51, 51, 51);">我们来跟踪一段代码</font></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    fmt.Println(&quot;Hello world&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(51, 51, 51);">接下来我们来针对上面的代码对调度器里面的结构做一个分析。</font></p>
<p><font style="color:rgb(51, 51, 51);">也会经历如上图所示的过程：</font></p>
<ol>
<li><font style="color:rgb(51, 51, 51);">runtime创建最初的线程m0和goroutine g0，并把2者关联。</font></li>
<li><font style="color:rgb(51, 51, 51);">调度器初始化：初始化m0、栈、垃圾回收，以及创建和初始化由GOMAXPROCS个P构成的P列表。</font></li>
<li><font style="color:rgb(51, 51, 51);">示例代码中的main函数是</font><font style="color:rgb(51, 51, 51);background-color:rgb(243, 244, 244);">main.main</font><font style="color:rgb(51, 51, 51);">，</font><font style="color:rgb(51, 51, 51);background-color:rgb(243, 244, 244);">runtime</font><font style="color:rgb(51, 51, 51);">中也有1个main函数——</font><font style="color:rgb(51, 51, 51);background-color:rgb(243, 244, 244);">runtime.main</font><font style="color:rgb(51, 51, 51);">，代码经过编译后，</font><font style="color:rgb(51, 51, 51);background-color:rgb(243, 244, 244);">runtime.main</font><font style="color:rgb(51, 51, 51);">会调用</font><font style="color:rgb(51, 51, 51);background-color:rgb(243, 244, 244);">main.main</font><font style="color:rgb(51, 51, 51);">，程序启动时会为</font><font style="color:rgb(51, 51, 51);background-color:rgb(243, 244, 244);">runtime.main</font><font style="color:rgb(51, 51, 51);">创建goroutine，称它为main goroutine吧，然后把main goroutine加入到P的本地队列。</font></li>
<li><font style="color:rgb(51, 51, 51);">启动m0，m0已经绑定了P，会从P的本地队列获取G，获取到main goroutine。</font></li>
<li><font style="color:rgb(51, 51, 51);">G拥有栈，M根据G中的栈信息和调度信息设置运行环境</font></li>
<li><font style="color:rgb(51, 51, 51);">M运行G</font></li>
<li><font style="color:rgb(51, 51, 51);">G退出，再次回到M获取可运行的G，这样重复下去，直到</font><font style="color:rgb(51, 51, 51);background-color:rgb(243, 244, 244);">main.main</font><font style="color:rgb(51, 51, 51);">退出，</font><font style="color:rgb(51, 51, 51);background-color:rgb(243, 244, 244);">runtime.main</font><font style="color:rgb(51, 51, 51);">执行Defer和Panic处理，或调用</font><font style="color:rgb(51, 51, 51);background-color:rgb(243, 244, 244);">runtime.exit</font><font style="color:rgb(51, 51, 51);">退出程序。</font></li>
</ol>
<p><font style="color:rgb(51, 51, 51);">调度器的生命周期几乎占满了一个Go程序的一生，</font><font style="color:rgb(51, 51, 51);background-color:rgb(243, 244, 244);">runtime.main</font><font style="color:rgb(51, 51, 51);">的goroutine执行之前都是为调度器做准备工作，</font><font style="color:rgb(51, 51, 51);background-color:rgb(243, 244, 244);">runtime.main</font><font style="color:rgb(51, 51, 51);">的goroutine运行，才是调度器的真正开始，直到</font><font style="color:rgb(51, 51, 51);background-color:rgb(243, 244, 244);">runtime.main</font><font style="color:rgb(51, 51, 51);">结束而结束。</font></p>
<h5 id="5-可视化GMP编程"><a href="#5-可视化GMP编程" class="headerlink" title="(5)可视化GMP编程"></a><font style="color:rgb(51, 51, 51);">(5)可视化GMP编程</font></h5><p><font style="color:rgb(51, 51, 51);">有2种方式可以查看一个程序的GMP的数据。</font></p>
<p><strong><font style="color:rgb(51, 51, 51);">方式1：go tool trace</font></strong></p>
<p><font style="color:rgb(51, 51, 51);">trace记录了运行时的信息，能提供可视化的Web页面。</font></p>
<p><font style="color:rgb(51, 51, 51);">简单测试代码：main函数创建trace，trace会运行在单独的goroutine中，然后main打印”Hello World”退出。</font></p>
<p><font style="color:rgb(119, 119, 119);">trace.go</font></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;runtime/trace&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建trace文件</span></span><br><span class="line">    f, err := os.Create(<span class="string">&quot;trace.out&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">defer</span> f.Close()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//启动trace goroutine</span></span><br><span class="line">    err = trace.Start(f)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> trace.Stop()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//main</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(51, 51, 51);">运行程序</font></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go run trace.go </span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(51, 51, 51);">会得到一个</font><font style="color:rgb(51, 51, 51);background-color:rgb(243, 244, 244);">trace.out</font><font style="color:rgb(51, 51, 51);">文件，然后我们可以用一个工具打开，来分析这个文件。</font></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ go tool trace trace.out </span><br><span class="line">2020/02/23 10:44:11 Parsing trace...</span><br><span class="line">2020/02/23 10:44:11 Splitting trace...</span><br><span class="line">2020/02/23 10:44:11 Opening browser. Trace viewer is listening on http://127.0.0.1:33479</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(51, 51, 51);">我们可以通过浏览器打开</font><font style="color:rgb(51, 51, 51);background-color:rgb(243, 244, 244);"><a target="_blank" rel="noopener" href="http://127.0.0.1:33479/">http://127.0.0.1:33479</a></font><font style="color:rgb(51, 51, 51);">网址，点击</font><font style="color:rgb(51, 51, 51);background-color:rgb(243, 244, 244);">view trace</font><font style="color:rgb(51, 51, 51);"> 能够看见可视化的调度流程。</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29334239/1683529378468-f7be6d52-438b-4902-b7ea-cd6b41be38c9.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29334239/1683529379036-d4524615-d54c-41bc-a674-e1f559b0a57b.png"></p>
<p><strong><font style="color:rgb(51, 51, 51);">G信息</font></strong></p>
<p><font style="color:rgb(51, 51, 51);">点击Goroutines那一行可视化的数据条，我们会看到一些详细的信息。</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29334239/1683529379481-6f9ead88-10b3-4e99-a49a-3706d5be3abe.png"></p>
<p>  一共有两个G在程序中，一个是特殊的G0，是每个M必须有的一个初始化的G，这个我们不必讨论。</p>
<p><font style="color:rgb(51, 51, 51);">其中G1应该就是main goroutine(执行main函数的协程)，在一段时间内处于可运行和运行的状态。</font></p>
<p><strong><font style="color:rgb(51, 51, 51);">M信息</font></strong></p>
<p><font style="color:rgb(51, 51, 51);">点击Threads那一行可视化的数据条，我们会看到一些详细的信息。</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29334239/1683529379633-10ac9720-9d28-469e-bdb7-369b5867de43.png"></p>
<p><font style="color:rgb(51, 51, 51);">一共有两个M在程序中，一个是特殊的M0，用于初始化使用，这个我们不必讨论。</font></p>
<p><strong><font style="color:rgb(51, 51, 51);">P信息</font></strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29334239/1683529379675-23843feb-d9c7-4060-937d-8e20d10a1730.png"></p>
<p><font style="color:rgb(51, 51, 51);">G1中调用了</font><font style="color:rgb(51, 51, 51);background-color:rgb(243, 244, 244);">main.main</font><font style="color:rgb(51, 51, 51);">，创建了</font><font style="color:rgb(51, 51, 51);background-color:rgb(243, 244, 244);">trace goroutine g18</font><font style="color:rgb(51, 51, 51);">。G1运行在P1上，G18运行在P0上。</font></p>
<p><font style="color:rgb(51, 51, 51);">这里有两个P，我们知道，一个P必须绑定一个M才能调度G。</font></p>
<p><font style="color:rgb(51, 51, 51);">我们在来看看上面的M信息。</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29334239/1683529379861-1fe02195-177c-4d7f-865b-c4105ded978b.png"></p>
<p><font style="color:rgb(51, 51, 51);">我们会发现，确实G18在P0上被运行的时候，确实在Threads行多了一个M的数据，点击查看如下：</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29334239/1683529380079-308a534f-0451-4e4d-9f3d-4a4008cf7d4e.png"></p>
<p><font style="color:rgb(51, 51, 51);">多了一个M2应该就是P0为了执行G18而动态创建的M2.</font></p>
<p><strong><font style="color:rgb(51, 51, 51);">方式2：Debug trace</font></strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">        fmt.Println(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(51, 51, 51);">编译</font></p>
<p>$ go build trace2.go</p>
<p><font style="color:rgb(51, 51, 51);">通过Debug方式运行</font></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ GODEBUG=schedtrace=<span class="number">1000</span> ./trace2 </span><br><span class="line">SCHED <span class="number">0</span>ms: gomaxprocs=<span class="number">2</span> idleprocs=<span class="number">0</span> threads=<span class="number">4</span> spinningthreads=<span class="number">1</span> idlethreads=<span class="number">1</span> runqueue=<span class="number">0</span> [<span class="number">0</span> <span class="number">0</span>]</span><br><span class="line">Hello World</span><br><span class="line">SCHED <span class="number">1003</span>ms: gomaxprocs=<span class="number">2</span> idleprocs=<span class="number">2</span> threads=<span class="number">4</span> spinningthreads=<span class="number">0</span> idlethreads=<span class="number">2</span> runqueue=<span class="number">0</span> [<span class="number">0</span> <span class="number">0</span>]</span><br><span class="line">Hello World</span><br><span class="line">SCHED <span class="number">2014</span>ms: gomaxprocs=<span class="number">2</span> idleprocs=<span class="number">2</span> threads=<span class="number">4</span> spinningthreads=<span class="number">0</span> idlethreads=<span class="number">2</span> runqueue=<span class="number">0</span> [<span class="number">0</span> <span class="number">0</span>]</span><br><span class="line">Hello World</span><br><span class="line">SCHED <span class="number">3015</span>ms: gomaxprocs=<span class="number">2</span> idleprocs=<span class="number">2</span> threads=<span class="number">4</span> spinningthreads=<span class="number">0</span> idlethreads=<span class="number">2</span> runqueue=<span class="number">0</span> [<span class="number">0</span> <span class="number">0</span>]</span><br><span class="line">Hello World</span><br><span class="line">SCHED <span class="number">4023</span>ms: gomaxprocs=<span class="number">2</span> idleprocs=<span class="number">2</span> threads=<span class="number">4</span> spinningthreads=<span class="number">0</span> idlethreads=<span class="number">2</span> runqueue=<span class="number">0</span> [<span class="number">0</span> <span class="number">0</span>]</span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure>

<ul>
<li><font style="color:rgb(51, 51, 51);background-color:rgb(243, 244, 244);">SCHED</font><font style="color:rgb(51, 51, 51);">：调试信息输出标志字符串，代表本行是goroutine调度器的输出；</font></li>
<li><font style="color:rgb(51, 51, 51);background-color:rgb(243, 244, 244);">0ms</font><font style="color:rgb(51, 51, 51);">：即从程序启动到输出这行日志的时间；</font></li>
<li><font style="color:rgb(51, 51, 51);background-color:rgb(243, 244, 244);">gomaxprocs</font><font style="color:rgb(51, 51, 51);">: P的数量，本例有2个P, 因为默认的P的属性是和cpu核心数量默认一致，当然也可以通过GOMAXPROCS来设置；</font></li>
<li><font style="color:rgb(51, 51, 51);background-color:rgb(243, 244, 244);">idleprocs</font><font style="color:rgb(51, 51, 51);">: 处于idle状态的P的数量；通过gomaxprocs和idleprocs的差值，我们就可知道执行go代码的P的数量；</font></li>
<li><font style="color:rgb(51, 51, 51);">t</font><font style="color:rgb(51, 51, 51);background-color:rgb(243, 244, 244);">hreads: os threads&#x2F;M</font><font style="color:rgb(51, 51, 51);">的数量，包含scheduler使用的m数量，加上runtime自用的类似sysmon这样的thread的数量；</font></li>
<li><font style="color:rgb(51, 51, 51);background-color:rgb(243, 244, 244);">spinningthreads</font><font style="color:rgb(51, 51, 51);">: 处于自旋状态的os thread数量；</font></li>
<li><font style="color:rgb(51, 51, 51);background-color:rgb(243, 244, 244);">idlethread</font><font style="color:rgb(51, 51, 51);">: 处于idle状态的os thread的数量；</font></li>
<li><font style="color:rgb(51, 51, 51);background-color:rgb(243, 244, 244);">runqueue&#x3D;0</font><font style="color:rgb(51, 51, 51);">： Scheduler全局队列中G的数量；</font></li>
<li><font style="color:rgb(51, 51, 51);background-color:rgb(243, 244, 244);">[0 0]</font><font style="color:rgb(51, 51, 51);">: 分别为2个P的local queue中的G的数量。</font></li>
</ul>
<p><font style="color:rgb(51, 51, 51);">下一篇，我们来继续详细的分析GMP调度原理的一些场景问题。</font></p>
<h4 id="三、Go调度器调度场景过程全解析"><a href="#三、Go调度器调度场景过程全解析" class="headerlink" title="三、Go调度器调度场景过程全解析"></a><font style="color:rgb(51, 51, 51);">三、Go调度器调度场景过程全解析</font></h4><h5 id="1-场景1"><a href="#1-场景1" class="headerlink" title="(1)场景1"></a><font style="color:rgb(51, 51, 51);">(1)场景1</font></h5><p><font style="color:rgb(51, 51, 51);">P拥有G1，M1获取P后开始运行G1，G1使用</font><font style="color:rgb(51, 51, 51);background-color:rgb(243, 244, 244);">go func()</font><font style="color:rgb(51, 51, 51);">创建了G2，为了局部性G2优先加入到P1的本地队列。</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29334239/1683529380605-fcefc64d-dc0c-4481-bd62-08a95f556748.png"></p>
<hr>
<h5 id="2-场景2"><a href="#2-场景2" class="headerlink" title="(2)场景2"></a><font style="color:rgb(51, 51, 51);">(2)场景2</font></h5><p><font style="color:rgb(51, 51, 51);">G1运行完成后(函数：</font><font style="color:rgb(51, 51, 51);background-color:rgb(243, 244, 244);">goexit</font><font style="color:rgb(51, 51, 51);">)，M上运行的goroutine切换为G0，G0负责调度时协程的切换（函数：</font><font style="color:rgb(51, 51, 51);background-color:rgb(243, 244, 244);">schedule</font><font style="color:rgb(51, 51, 51);">）。从P的本地队列取G2，从G0切换到G2，并开始运行G2(函数：</font><font style="color:rgb(51, 51, 51);background-color:rgb(243, 244, 244);">execute</font><font style="color:rgb(51, 51, 51);">)。实现了线程M1的复用。</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29334239/1683529381153-96edc495-2ac9-4172-af1f-a5145f454f5d.png"></p>
<hr>
<h5 id="3-场景3"><a href="#3-场景3" class="headerlink" title="(3)场景3"></a><font style="color:rgb(51, 51, 51);">(3)场景3</font></h5><p><font style="color:rgb(51, 51, 51);">假设每个P的本地队列只能存3个G。G2要创建了6个G，前3个G（G3, G4, G5）已经加入p1的本地队列，p1本地队列满了。</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29334239/1683529381159-e73861ee-71d2-4ca5-89a7-48e5e5016b44.png"></p>
<hr>
<h5 id="4-场景4"><a href="#4-场景4" class="headerlink" title="(4)场景4"></a><font style="color:rgb(51, 51, 51);">(4)场景4</font></h5><p><font style="color:rgb(51, 51, 51);">G2在创建G7的时候，发现P1的本地队列已满，需要执行</font><strong><font style="color:rgb(51, 51, 51);">负载均衡</font></strong><font style="color:rgb(51, 51, 51);">(把P1中本地队列中前一半的G，还有新创建G</font><strong><font style="color:rgb(51, 51, 51);">转移</font></strong><font style="color:rgb(51, 51, 51);">到全局队列)</font></p>
<p><font style="color:rgb(119, 119, 119);">（实现中并不一定是新的G，如果G是G2之后就执行的，会被保存在本地队列，利用某个老的G替换新G加入全局队列）</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29334239/1683529381222-beafc2d4-6a09-4729-b1ef-b32beda8f692.png"></p>
<p><font style="color:rgb(51, 51, 51);">这些G被转移到全局队列时，会被打乱顺序。所以G3,G4,G7被转移到全局队列。</font></p>
<hr>
<h5 id="5-场景5"><a href="#5-场景5" class="headerlink" title="(5)场景5"></a><font style="color:rgb(51, 51, 51);">(5)场景5</font></h5><p><font style="color:rgb(51, 51, 51);">G2创建G8时，P1的本地队列未满，所以G8会被加入到P1的本地队列。</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29334239/1683529381242-d33e0861-8b2d-4d3c-9ccd-ca0be345bf8c.png"></p>
<p><font style="color:rgb(51, 51, 51);">G8加入到P1点本地队列的原因还是因为P1此时在与M1绑定，而G2此时是M1在执行。所以G2创建的新的G会优先放置到自己的M绑定的P上。</font></p>
<hr>
<h5 id="6-场景6"><a href="#6-场景6" class="headerlink" title="(6)场景6"></a><font style="color:rgb(51, 51, 51);">(6)场景6</font></h5><p><font style="color:rgb(51, 51, 51);">规定：</font><strong><font style="color:rgb(51, 51, 51);">在创建G时，运行的G会尝试唤醒其他空闲的P和M组合去执行</font></strong><font style="color:rgb(51, 51, 51);">。</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29334239/1683529381714-b2a0b647-d787-4479-9385-9872795e44cf.png"></p>
<p><font style="color:rgb(51, 51, 51);">假定G2唤醒了M2，M2绑定了P2，并运行G0，但P2本地队列没有G，M2此时为自旋线程</font><strong><font style="color:rgb(51, 51, 51);">（没有G但为运行状态的线程，不断寻找G）</font></strong><font style="color:rgb(51, 51, 51);">。</font></p>
<hr>
<h5 id="7-场景7"><a href="#7-场景7" class="headerlink" title="(7)场景7"></a><font style="color:rgb(51, 51, 51);">(7)场景7</font></h5><p><font style="color:rgb(51, 51, 51);">M2尝试从全局队列(简称“GQ”)取一批G放到P2的本地队列（函数：</font><font style="color:rgb(51, 51, 51);background-color:rgb(243, 244, 244);">findrunnable()</font><font style="color:rgb(51, 51, 51);">）。M2从全局队列取的G数量符合下面的公式：</font></p>
<p>n &#x3D; min(len(GQ)&#x2F;GOMAXPROCS + 1, len(GQ&#x2F;2))</p>
<p><font style="color:rgb(51, 51, 51);">至少从全局队列取1个g，但每次不要从全局队列移动太多的g到p本地队列，给其他p留点。这是</font><strong><font style="color:rgb(51, 51, 51);">从全局队列到P本地队列的负载均衡</font></strong><font style="color:rgb(51, 51, 51);">。</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29334239/1683529382326-69796520-9e6e-4801-be2a-dcd815b58496.png"></p>
<p><font style="color:rgb(51, 51, 51);">假定我们场景中一共有4个P（GOMAXPROCS设置为4，那么我们允许最多就能用4个P来供M使用）。所以M2只从能从全局队列取1个G（即G3）移动P2本地队列，然后完成从G0到G3的切换，运行G3。</font></p>
<hr>
<h5 id="8-场景8"><a href="#8-场景8" class="headerlink" title="(8)场景8"></a><font style="color:rgb(51, 51, 51);">(8)场景8</font></h5><p><font style="color:rgb(51, 51, 51);">假设G2一直在M1上运行，经过2轮后，M2已经把G7、G4从全局队列获取到了P2的本地队列并完成运行，全局队列和P2的本地队列都空了,如场景8图的左半部分。</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29334239/1683529382411-546914f9-80f0-464c-8a7d-d56d07878cfb.png"></p>
<p><strong><font style="color:rgb(51, 51, 51);">全局队列已经没有G，那m就要执行work stealing(偷取)：从其他有G的P哪里偷取一半G过来，放到自己的P本地队列</font></strong><font style="color:rgb(51, 51, 51);">。P2从P1的本地队列尾部取一半的G，本例中一半则只有1个G8，放到P2的本地队列并执行。</font></p>
<hr>
<h5 id="9-场景9"><a href="#9-场景9" class="headerlink" title="(9)场景9"></a><font style="color:rgb(51, 51, 51);">(9)场景9</font></h5><p><font style="color:rgb(51, 51, 51);">G1本地队列G5、G6已经被其他M偷走并运行完成，当前M1和M2分别在运行G2和G8，M3和M4没有goroutine可以运行，M3和M4处于</font><strong><font style="color:rgb(51, 51, 51);">自旋状态</font></strong><font style="color:rgb(51, 51, 51);">，它们不断寻找goroutine。</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29334239/1683529382519-5a37aba8-95b4-465f-b26e-14c81cfdcffd.png"></p>
<p><font style="color:rgb(51, 51, 51);">为什么要让m3和m4自旋，自旋本质是在运行，线程在运行却没有执行G，就变成了浪费CPU. 为什么不销毁现场，来节约CPU资源。因为创建和销毁CPU也会浪费时间，我们</font><strong><font style="color:rgb(51, 51, 51);">希望当有新goroutine创建时，立刻能有M运行它</font></strong><font style="color:rgb(51, 51, 51);">，如果销毁再新建就增加了时延，降低了效率。当然也考虑了过多的自旋线程是浪费CPU，所以系统中最多有</font><font style="color:rgb(51, 51, 51);background-color:rgb(243, 244, 244);">GOMAXPROCS</font><font style="color:rgb(51, 51, 51);">个自旋的线程(当前例子中的</font><font style="color:rgb(51, 51, 51);background-color:rgb(243, 244, 244);">GOMAXPROCS</font><font style="color:rgb(51, 51, 51);">&#x3D;4，所以一共4个P)，多余的没事做线程会让他们休眠。</font></p>
<hr>
<h5 id="10-场景10"><a href="#10-场景10" class="headerlink" title="(10)场景10"></a><font style="color:rgb(51, 51, 51);">(10)场景10</font></h5><p><font style="color:rgb(51, 51, 51);">假定当前除了M3和M4为自旋线程，还有M5和M6为空闲的线程(没有得到P的绑定，注意我们这里最多就只能够存在4个P，所以P的数量应该永远是M&gt;&#x3D;P, 大部分都是M在抢占需要运行的P)，G8创建了G9，G8进行了</font><strong><font style="color:rgb(51, 51, 51);">阻塞的系统调用</font></strong><font style="color:rgb(51, 51, 51);">，M2和P2立即解绑，P2会执行以下判断：如果P2本地队列有G、全局队列有G或有空闲的M，P2都会立马唤醒1个M和它绑定，否则P2则会加入到空闲P列表，等待M来获取可用的p。本场景中，P2本地队列有G9，可以和其他空闲的线程M5绑定。</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29334239/1683529383098-da914ca4-5731-4860-9654-af4accbdfdcb.png"></p>
<h5 id="11-场景11"><a href="#11-场景11" class="headerlink" title="(11)场景11"></a><font style="color:rgb(51, 51, 51);">(11)场景11</font></h5><p><font style="color:rgb(51, 51, 51);">G8创建了G9，假如G8进行了</font><strong><font style="color:rgb(51, 51, 51);">非阻塞系统调用</font></strong><font style="color:rgb(51, 51, 51);">。</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29334239/1683529383019-ecaee668-7b20-40f9-98e0-c261889dd704.png"></p>
<p><font style="color:rgb(51, 51, 51);">M2和P2会解绑，但M2会记住P2，然后G8和M2进入</font><strong><font style="color:rgb(51, 51, 51);">系统调用</font></strong><font style="color:rgb(51, 51, 51);">状态。当G8和M2退出系统调用时，会尝试获取P2，如果无法获取，则获取空闲的P，如果依然没有，G8会被记为可运行状态，并加入到全局队列,M2因为没有P的绑定而变成休眠状态(长时间休眠等待GC回收销毁)。</font></p>
<hr>
<h4 id="四、小结"><a href="#四、小结" class="headerlink" title="四、小结"></a><font style="color:rgb(51, 51, 51);">四、小结</font></h4><p><font style="color:rgb(51, 51, 51);">总结，Go调度器很轻量也很简单，足以撑起goroutine的调度工作，并且让Go具有了原生（强大）并发的能力。</font><strong><font style="color:rgb(51, 51, 51);">Go调度本质是把大量的goroutine分配到少量线程上去执行，并利用多核并行，实现更强大的并发。</font></strong></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">igl1t</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/02/04/%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%99%A8%E5%8E%9F%E7%90%86%E5%8F%8AGMP%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/">http://example.com/2025/02/04/%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%99%A8%E5%8E%9F%E7%90%86%E5%8F%8AGMP%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">igl1t's blog</a>！</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/02/04/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E5%B7%A5%E5%85%B7-wire/" title="依赖注入工具-wire"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">依赖注入工具-wire</div></div><div class="info-2"><div class="info-item-1">wire 简介Wire 是一种代码生成工具，其使用依赖注入自动连接组件。 在 Wire 中，组件之间的依赖关系是通过函数参数来表示的。 组件 B 依赖组件 A，那么构造组件 B 的函数大致需要定义为：NewB(a A) B。 这里，鼓励显式初始化组件 A，而不是，定义一个组件 A 全局变量，然后不通过传参而直接在 NewB 函数中使用全局变量。 wire 安装1go get github.com/google/wire/cmd/wire  确保 $GOPATH&#x2F;bin 已添加到 $PATH 环境变量。 wire 基础概念在 wire 中，有两个核心概念：Providers、Injectors。 Providerswire 的主要机制是 Provider：具有返回值的函数。 这些函数都是常规的 go 代码。 12345678910package foobarbaztype Foo struct &#123;    X int&#125;// ProvideFoo 函数返回一个 Foo 结构体值。func ProvideFoo() Foo &#123;    return...</div></div></div></a><a class="pagination-related" href="/2025/02/04/client-go%E5%8E%9F%E7%90%86/" title="client-go详解"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">client-go详解</div></div><div class="info-2"><div class="info-item-1">client-go简介client-go是一个调用Kubernetes集群资源对象API的客户端，即通过client-go实现对Kubernetes集群中资源对象（包括deployment、service、ingress、replicaSet、pod、namespace、node等）的增删改查操作。大部分对Kubernetes进行前置API封装的二次开发都通过client-go这个第三方包来实现。 client-go目录结构12345678910111213.├── discovery                   # 定义DsicoveryClient客户端。作用是用于发现k8s所支持GVR(Group, Version, Resources)。├── dynamic                     # 定义DynamicClient客户端。可以用于访问k8s Resources(如: Pod, Deploy...)，也可以访问用户自定义资源(即: CRD)。├── informers                   #...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">igl1t</div><div class="author-info-description">某不知名黑客</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">13</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Golang%E7%9A%84%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%99%A8%E5%8E%9F%E7%90%86%E5%8F%8AGMP%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3"><span class="toc-number">1.</span> <span class="toc-text">Golang的协程调度器原理及GMP设计思想</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E3%80%81Golang%E2%80%9C%E8%B0%83%E5%BA%A6%E5%99%A8%E2%80%9D%E7%9A%84%E7%94%B1%E6%9D%A5%EF%BC%9F"><span class="toc-number">1.0.0.1.</span> <span class="toc-text">一、Golang“调度器”的由来？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%8D%95%E8%BF%9B%E7%A8%8B%E6%97%B6%E4%BB%A3%E4%B8%8D%E9%9C%80%E8%A6%81%E8%B0%83%E5%BA%A6%E5%99%A8"><span class="toc-number">1.0.0.1.1.</span> <span class="toc-text">(1) 单进程时代不需要调度器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%A4%9A%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E6%97%B6%E4%BB%A3%E6%9C%89%E4%BA%86%E8%B0%83%E5%BA%A6%E5%99%A8%E9%9C%80%E6%B1%82"><span class="toc-number">1.0.0.1.2.</span> <span class="toc-text">(2)多进程&#x2F;线程时代有了调度器需求</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%8D%8F%E7%A8%8B%E6%9D%A5%E6%8F%90%E9%AB%98CPU%E5%88%A9%E7%94%A8%E7%8E%87"><span class="toc-number">1.0.0.1.3.</span> <span class="toc-text">(3)协程来提高CPU利用率</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#N-1%E5%85%B3%E7%B3%BB"><span class="toc-number">1.0.0.2.</span> <span class="toc-text">N:1关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E5%85%B3%E7%B3%BB"><span class="toc-number">1.0.0.3.</span> <span class="toc-text">1:1 关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#M-N%E5%85%B3%E7%B3%BB"><span class="toc-number">1.0.0.4.</span> <span class="toc-text">M:N关系</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-Go%E8%AF%AD%E8%A8%80%E7%9A%84%E5%8D%8F%E7%A8%8Bgoroutine"><span class="toc-number">1.0.0.4.1.</span> <span class="toc-text">(4)Go语言的协程goroutine</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E8%A2%AB%E5%BA%9F%E5%BC%83%E7%9A%84goroutine%E8%B0%83%E5%BA%A6%E5%99%A8"><span class="toc-number">1.0.0.4.2.</span> <span class="toc-text">(5)被废弃的goroutine调度器</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Goroutine%E8%B0%83%E5%BA%A6%E5%99%A8%E7%9A%84GMP%E6%A8%A1%E5%9E%8B%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3"><span class="toc-number">1.0.0.5.</span> <span class="toc-text">二、Goroutine调度器的GMP模型的设计思想</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-GMP%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.0.0.5.1.</span> <span class="toc-text">(1)GMP模型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%85%B3P%E5%92%8CM%E7%9A%84%E4%B8%AA%E6%95%B0%E9%97%AE%E9%A2%98"><span class="toc-number">1.0.1.</span> <span class="toc-text">有关P和M的个数问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#P%E5%92%8CM%E4%BD%95%E6%97%B6%E4%BC%9A%E8%A2%AB%E5%88%9B%E5%BB%BA"><span class="toc-number">1.0.2.</span> <span class="toc-text">P和M何时会被创建</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E8%B0%83%E5%BA%A6%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E7%AD%96%E7%95%A5"><span class="toc-number">1.0.2.0.1.</span> <span class="toc-text">(2)调度器的设计策略</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-go-func-%E8%B0%83%E5%BA%A6%E6%B5%81%E7%A8%8B"><span class="toc-number">1.0.2.0.2.</span> <span class="toc-text">(3) go func() 调度流程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E8%B0%83%E5%BA%A6%E5%99%A8%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.0.2.0.3.</span> <span class="toc-text">(4)调度器的生命周期</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E5%8F%AF%E8%A7%86%E5%8C%96GMP%E7%BC%96%E7%A8%8B"><span class="toc-number">1.0.2.0.4.</span> <span class="toc-text">(5)可视化GMP编程</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E3%80%81Go%E8%B0%83%E5%BA%A6%E5%99%A8%E8%B0%83%E5%BA%A6%E5%9C%BA%E6%99%AF%E8%BF%87%E7%A8%8B%E5%85%A8%E8%A7%A3%E6%9E%90"><span class="toc-number">1.0.2.1.</span> <span class="toc-text">三、Go调度器调度场景过程全解析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%9C%BA%E6%99%AF1"><span class="toc-number">1.0.2.1.1.</span> <span class="toc-text">(1)场景1</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%9C%BA%E6%99%AF2"><span class="toc-number">1.0.2.1.2.</span> <span class="toc-text">(2)场景2</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%9C%BA%E6%99%AF3"><span class="toc-number">1.0.2.1.3.</span> <span class="toc-text">(3)场景3</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E5%9C%BA%E6%99%AF4"><span class="toc-number">1.0.2.1.4.</span> <span class="toc-text">(4)场景4</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E5%9C%BA%E6%99%AF5"><span class="toc-number">1.0.2.1.5.</span> <span class="toc-text">(5)场景5</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-%E5%9C%BA%E6%99%AF6"><span class="toc-number">1.0.2.1.6.</span> <span class="toc-text">(6)场景6</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-%E5%9C%BA%E6%99%AF7"><span class="toc-number">1.0.2.1.7.</span> <span class="toc-text">(7)场景7</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-%E5%9C%BA%E6%99%AF8"><span class="toc-number">1.0.2.1.8.</span> <span class="toc-text">(8)场景8</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-%E5%9C%BA%E6%99%AF9"><span class="toc-number">1.0.2.1.9.</span> <span class="toc-text">(9)场景9</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#10-%E5%9C%BA%E6%99%AF10"><span class="toc-number">1.0.2.1.10.</span> <span class="toc-text">(10)场景10</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#11-%E5%9C%BA%E6%99%AF11"><span class="toc-number">1.0.2.1.11.</span> <span class="toc-text">(11)场景11</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%B0%8F%E7%BB%93"><span class="toc-number">1.0.2.2.</span> <span class="toc-text">四、小结</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/04/channel/" title="channel使用">channel使用</a><time datetime="2025-02-04T12:52:00.038Z" title="发表于 2025-02-04 20:52:00">2025-02-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/04/yaml%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/" title="yaml文件详解">yaml文件详解</a><time datetime="2025-02-04T12:52:00.035Z" title="发表于 2025-02-04 20:52:00">2025-02-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/04/SingleFlight/" title="SingleFlight">SingleFlight</a><time datetime="2025-02-04T12:52:00.034Z" title="发表于 2025-02-04 20:52:00">2025-02-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/04/vim%E6%89%93%E9%80%A0%E6%88%90idea/" title="vim打造成ide">vim打造成ide</a><time datetime="2025-02-04T12:52:00.033Z" title="发表于 2025-02-04 20:52:00">2025-02-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/04/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/" title="io 多路复用">io 多路复用</a><time datetime="2025-02-04T12:52:00.031Z" title="发表于 2025-02-04 20:52:00">2025-02-04</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By igl1t</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>