<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>client-go详解 | igl1t's blog</title><meta name="author" content="igl1t"><meta name="copyright" content="igl1t"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="client-go简介client-go是一个调用Kubernetes集群资源对象API的客户端，即通过client-go实现对Kubernetes集群中资源对象（包括deployment、service、ingress、replicaSet、pod、namespace、node等）的增删改查操作。大部分对Kubernetes进行前置API封装的二次开发都通过client-go这个第三方包来实现。">
<meta property="og:type" content="article">
<meta property="og:title" content="client-go详解">
<meta property="og:url" content="http://example.com/2025/02/04/client-go%E5%8E%9F%E7%90%86/index.html">
<meta property="og:site_name" content="igl1t&#39;s blog">
<meta property="og:description" content="client-go简介client-go是一个调用Kubernetes集群资源对象API的客户端，即通过client-go实现对Kubernetes集群中资源对象（包括deployment、service、ingress、replicaSet、pod、namespace、node等）的增删改查操作。大部分对Kubernetes进行前置API封装的二次开发都通过client-go这个第三方包来实现。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/butterfly-icon.png">
<meta property="article:published_time" content="2025-02-04T12:52:00.029Z">
<meta property="article:modified_time" content="2025-02-04T07:51:07.000Z">
<meta property="article:author" content="igl1t">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "client-go详解",
  "url": "http://example.com/2025/02/04/client-go%E5%8E%9F%E7%90%86/",
  "image": "http://example.com/img/butterfly-icon.png",
  "datePublished": "2025-02-04T12:52:00.029Z",
  "dateModified": "2025-02-04T07:51:07.000Z",
  "author": [
    {
      "@type": "Person",
      "name": "igl1t",
      "url": "http://example.com/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2025/02/04/client-go%E5%8E%9F%E7%90%86/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'client-go详解',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(/img/back.png);"></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/back.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">igl1t's blog</span></a><a class="nav-page-title" href="/"><span class="site-name">client-go详解</span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">client-go详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-02-04T12:52:00.029Z" title="发表于 2025-02-04 20:52:00">2025-02-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-02-04T07:51:07.000Z" title="更新于 2025-02-04 15:51:07">2025-02-04</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="client-go简介"><a href="#client-go简介" class="headerlink" title="client-go简介"></a>client-go简介</h1><p>client-go是一个调用Kubernetes集群资源对象API的客户端，即通过client-go实现对Kubernetes集群中资源对象（包括deployment、service、ingress、replicaSet、pod、namespace、node等）的增删改查操作。大部分对Kubernetes进行前置API封装的二次开发都通过client-go这个第三方包来实现。</p>
<h1 id="client-go目录结构"><a href="#client-go目录结构" class="headerlink" title="client-go目录结构"></a>client-go目录结构</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── discovery                   # 定义DsicoveryClient客户端。作用是用于发现k8s所支持GVR(Group, Version, Resources)。</span><br><span class="line">├── dynamic                     # 定义DynamicClient客户端。可以用于访问k8s Resources(如: Pod, Deploy...)，也可以访问用户自定义资源(即: CRD)。</span><br><span class="line">├── informers                   # k8s中各种Resources的Informer机制的实现。</span><br><span class="line">├── kubernetes                  # 定义ClientSet客户端。它只能用于访问k8s Resources。每一种资源(如: Pod等)都可以看成是一个客端，而ClientSet是多个客户端的集合，它对RestClient进行了封装，引入了对Resources和Version的管理。通常来说ClientSet是client-gen来自动生成的。</span><br><span class="line">├── listers                     # 提供对Resources的获取功能。对于Get()和List()而言，listers提供给二者的数据都是从缓存中读取的。</span><br><span class="line">├── pkg                         </span><br><span class="line">├── plugin                      # 提供第三方插件。如：GCP, OpenStack等。</span><br><span class="line">├── rest                        # 定义RestClient，实现了Restful的API。同时会支持Protobuf和Json格式数据。</span><br><span class="line">├── scale                       # 定义ScalClient。用于Deploy, RS, RC等的扩/缩容。</span><br><span class="line">├── tools                       # 定义诸如SharedInformer、Reflector、DealtFIFO和Indexer等常用工具。实现client查询和缓存机制，减少client与api-server请求次数，减少api-server的压力。</span><br><span class="line">├── transport</span><br><span class="line">└── util                        # 提供诸如WorkQueue、Certificate等常用方法。</span><br></pre></td></tr></table></figure>

<h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><ol>
<li>初始化rest.Config对象，用来初始化client。</li>
<li>按需初始化client。</li>
<li>进行具体的crud。</li>
</ol>
<img src="/Users/goiruri/Library/Application Support/typora-user-images/image-20231109195552271.png" alt="image-20231109195552271" style="zoom:33%;" />

<p>RESTClient是所有客户端的父类，底层调用了Go语言<code>net\http</code>库，访问API Server的RESTful接口。</p>
<h2 id="ClientSet"><a href="#ClientSet" class="headerlink" title="ClientSet"></a>ClientSet</h2><p>ClientSet是使用最多的客户端，它继承自RESTClient，使用K8s的代码生成机制(client-gen机制)，在编译过程中，会根据目前K8s内置的资源信息，自动生成他们的客户端代码(前提是需要添加适当的注解)，使用者可以通过builder pattern进行初始化，得到自己在意的目标资源类型的客户端。ClientSet如同它的名字一样，代表的是一组内置资源的客户端。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">clientset, err := kubernetes.NewForConfig(config) <span class="comment">// 根据config对象创建clientSet对象</span></span><br><span class="line">mustSuccess(err)</span><br><span class="line">podClient := clientset.CoreV1().Pods(&amp;quot;development&amp;quot;) <span class="comment">// 根据Pod资源的Group、Version、Recource Name创建资源定制客户端，传入的字符串表示资源所在的ns；podClient对象具有List\Update\Delete\Patch\Get等curd接口</span></span><br></pre></td></tr></table></figure>

<h2 id="DynamicClient"><a href="#DynamicClient" class="headerlink" title="DynamicClient"></a>DynamicClient</h2><p><code>DynamiClient</code>动态客户端，可以根据传入的<code>GVR(group version resource)</code>生成一个可以操作特定资源的客户端。但是不是内存安全的客户端，返回的结果通常是非结构化的。需要额外经过一次类型转换才能变为目标资源类型的对象，这一步存在内存安全的风险。相比<code>ClientSet</code>,动态客户端不局限于K8s的内置资源，可以用于处理<code>CRD(custome resource define)</code>自定义资源，但是缺点在于安全性不高。<code>DynamicClient</code>使用的样例代码如下：</p>
<blockquote>
<p>结构化的类型通常属于k8s runtime object的子类型；非结构化的对象通常是map[string]interface{}的形式，通过一个字典存储对象的属性；K8s所有的内置资源都可以通过代码生成机制，拥有默认的资源转换方法</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">dynamicClient, err := dynamic.NewForConfig(config)</span><br><span class="line">mustSuccess(err)</span><br><span class="line">gvr := schema.GroupVersionResource&#123;Version: &amp;quot;v1&amp;quot;, Resource: &amp;quot;pods&amp;quot;&#125;</span><br><span class="line"><span class="comment">// 返回非结构化的对象</span></span><br><span class="line">unstructObj, err := dynamicClient.Resource(gvr).Namespace(&amp;quot;sandbox&amp;quot;).List(context.TODO(), metav1.ListOptions&#123;Limit: <span class="number">40</span>&#125;)</span><br><span class="line">mustSuccess(err)</span><br><span class="line">podList := &amp;amp;corev1.PodList&#123;&#125;</span><br><span class="line"><span class="comment">// 额外做一次类型转换,如果这里传错类型，就会有类型安全的风险</span></span><br><span class="line">err = runtime.DefaultUnstructuredConverter.FromUnstructured(unstructObj.UnstructuredContent(), podList)</span><br><span class="line">mustSuccess(err)</span><br><span class="line"><span class="keyword">for</span> _, po := <span class="keyword">range</span> podList.Items &#123;</span><br><span class="line">    fmt.Printf(&amp;quot;NAMESPACE: %v \t NAME: %v \t STATUS: %v \n&amp;quot;, po.Namespace, po.Name, po.Status)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="DiscoveryClient"><a href="#DiscoveryClient" class="headerlink" title="DiscoveryClient"></a>DiscoveryClient</h2><p><code>DiscoveryClient</code>发现客户端，主要用于处理向服务端请求当前集群支持的资源信息，例如命令<code>kubectl api-resources</code>使用的就是发现客户端，由于发现客户端获取的数据量比较大，并且集群的资源信息变更并不频繁，因此发现客户端会在本地建立文件缓存，默认十分钟之内的请求，使用本地缓存，超过十分钟之后则重新请求服务端。<code>DiscoveryClient</code>的使用样例代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">discoveryClient, err := discovery.NewDiscoveryClientForConfig(config)</span><br><span class="line">mustSuccess(err)</span><br><span class="line"></span><br><span class="line">_, APIResourceList, err := discoveryClient.ServerGroupsAndResources()</span><br><span class="line">mustSuccess(err)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, list := <span class="keyword">range</span> APIResourceList &#123;</span><br><span class="line">    gv, err := schema.ParseGroupVersion(list.GroupVersion)</span><br><span class="line">    mustSuccess(err)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, resource := <span class="keyword">range</span> list.APIResources &#123;</span><br><span class="line">        fmt.Printf(&amp;quot;name: %v \t group: %v \t verison: %v \n&amp;quot;,</span><br><span class="line">                   resource.Name, gv.Group, gv.Version)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h2><table>
<thead>
<tr>
<th>客户端名称</th>
<th>源码目录</th>
<th>简单描述</th>
</tr>
</thead>
<tbody><tr>
<td>RESTClient</td>
<td>client-go&#x2F;rest&#x2F;</td>
<td>基础客户端，对HTTP Request封装</td>
</tr>
<tr>
<td>ClientSet</td>
<td>client-go&#x2F;kubernetes&#x2F;</td>
<td>在RESTClient基础上封装了对Resource和Version，也就是说我们使用ClientSet的话是必须要知道Resource和Version， 例如AppsV1().Deployments或者CoreV1.Pods，缺点是不能访问CRD自定义资源</td>
</tr>
<tr>
<td>DynamicClient</td>
<td>client-go&#x2F;dynamic&#x2F;</td>
<td>包含一组动态的客户端，可以对任意的K8S API对象执行通用操作，包括CRD自定义资源</td>
</tr>
<tr>
<td>DiscoveryClient</td>
<td>client-go&#x2F;discovery&#x2F;</td>
<td>ClientSet必须要知道Resource和Version, 但使用者通常很难记住所有的GVR信息，这个DiscoveryClient是提供一个发现客户端，发现API Server支持的资源组，资源版本和资源信息</td>
</tr>
</tbody></table>
<h1 id="client-go内部原理"><a href="#client-go内部原理" class="headerlink" title="client-go内部原理"></a>client-go内部原理</h1><p>![image-20231110113355125](&#x2F;Users&#x2F;goiruri&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20231110113355125.png)</p>
<p>![image-20231110113147395](&#x2F;Users&#x2F;goiruri&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20231110113147395.png)</p>
<h2 id="各组件介绍"><a href="#各组件介绍" class="headerlink" title="各组件介绍"></a>各组件介绍</h2><ol>
<li><strong>client-go 组件</strong><ul>
<li><strong>Reflector</strong>: 定义在 <a target="_blank" rel="noopener" href="https://github.com/kubernetes/client-go/blob/master/tools/cache/reflector.go">&#x2F;tools&#x2F;cache 包内的 Reflector 类型</a> 中的 reflector 监视 Kubernetes API 以获取指定的资源类型 (Kind)。完成此操作的函数是 ListAndWatch。监视可以用于内建资源，也可以用于自定义资源。当 reflector 通过监视 API 的收到关于新资源实例存在的通知时，它使用相应的 listing API 获取新创建的对象，并将其放入 watchHandler 函数内的 Delta Fifo 队列中。</li>
<li><strong>Informer</strong>: 在 <a target="_blank" rel="noopener" href="https://github.com/kubernetes/client-go/blob/master/tools/cache/controller.go">&#x2F;tools&#x2F;cache 包内的基础 controller</a> 中定义的一个 informer 从 Delta FIFO 队列中弹出对象。完成此操作的函数是 processLoop。这个基础 controller 的任务是保存对象以供以后检索，并调用 controller 将对象传递给它。</li>
<li><strong>Indexer</strong>: indexer 为对象提供索引功能。它定义在 <a target="_blank" rel="noopener" href="https://github.com/kubernetes/client-go/blob/master/tools/cache/index.go">&#x2F;tools&#x2F;cache 包内的 Indexer 类型</a>。一个典型的索引用例是基于对象标签创建索引。Indexer 可以基于多个索引函数维护索引。Indexer 使用线程安全的数据存储来存储对象及其键值。在 <a target="_blank" rel="noopener" href="https://github.com/kubernetes/client-go/blob/master/tools/cache/store.go">&#x2F;tools&#x2F;cache 包内的 Store 类型</a> 定义了一个名为<code>MetaNamespaceKeyFunc</code>的默认函数，该函数为该对象生成一个名为 <code>&lt;namespace&gt;/&lt;name&gt;</code> 组合的对象键值。</li>
</ul>
</li>
<li><strong>Custom Controller 组件</strong><ul>
<li><strong>Informer reference</strong>: 这是一个知道如何使用自定义资源对象的 Informer 实例的引用。您的自定义控制器代码需要创建适当的 Informer。</li>
<li><strong>Indexer reference</strong>: 这是一个知道如何使用自定义资源对象的 Indexer 实例的引用。您的自定义控制器代码需要创建这个。您将使用此引用检索对象，以便稍后处理。</li>
<li><strong>Resource Event Handlers</strong>: 当 Informer 想要分发一个对象给你的控制器时，会调用这些回调函数。编写这些函数的典型模式是获取已分配对象的键值，并将该键值放入一个工作队列中进行进一步处理。</li>
<li><strong>Work queue</strong>: 这是在控制器代码中创建的队列，用于将对象的分发与处理解耦。编写 Resource Event Handler 函数来提取所分发对象的键值并将其添加到工作队列中。</li>
<li><strong>Process Item</strong>: 这是在代码中创建的处理 work queue 中的 items 的函数。可以有一个或多个其他函数来执行实际的处理。这些函数通常使用 <a target="_blank" rel="noopener" href="https://github.com/kubernetes/client-go/blob/master/examples/workqueue/main.go#L73">Indexer 引用</a> 或 Listing wrapper 来获取与键值对应的对象。</li>
</ul>
</li>
</ol>
<h2 id="流程-1"><a href="#流程-1" class="headerlink" title="流程"></a>流程</h2><h2 id="Indexer"><a href="#Indexer" class="headerlink" title="Indexer"></a>Indexer</h2><p>Indexer主要依赖于ThreadSafeStore实现，是client-go提供的一种缓存机制，通过检索本地缓存可以有效降低apiserver的压力</p>
<p>![image-20231110113653209](&#x2F;Users&#x2F;goiruri&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20231110113653209.png)</p>
<h3 id="Indexer接口"><a href="#Indexer接口" class="headerlink" title="Indexer接口"></a>Indexer接口</h3><p>Indexer接口主要是在Store接口的基础上拓展了对象的检索功能：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Indexer <span class="keyword">interface</span> &#123;</span><br><span class="line">   Store</span><br><span class="line">   Index(indexName <span class="type">string</span>, obj <span class="keyword">interface</span>&#123;&#125;) ([]<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>) <span class="comment">// 根据索引名和给定的对象返回符合条件的所有对象</span></span><br><span class="line">   IndexKeys(indexName, indexedValue <span class="type">string</span>) ([]<span class="type">string</span>, <span class="type">error</span>)     <span class="comment">// 根据索引名和索引值返回符合条件的所有对象的 key</span></span><br><span class="line">   ListIndexFuncValues(indexName <span class="type">string</span>) []<span class="type">string</span>                  <span class="comment">// 列出索引函数计算出来的所有索引值</span></span><br><span class="line">   ByIndex(indexName, indexedValue <span class="type">string</span>) ([]<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>)  <span class="comment">// 根据索引名和索引值返回符合条件的所有对象</span></span><br><span class="line">   GetIndexers() Indexers                     <span class="comment">// 获取所有的 Indexers，对应 map[string]IndexFunc 类型</span></span><br><span class="line">   AddIndexers(newIndexers Indexers) <span class="type">error</span>    <span class="comment">// 这个方法要在数据加入存储前调用，添加更多的索引方法，默认只通过 namespace 检索</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Indexer的默认实现是cache：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> cache <span class="keyword">struct</span> &#123;</span><br><span class="line">   cacheStorage ThreadSafeStore</span><br><span class="line">   keyFunc KeyFunc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>cache对应两个方法体实现完全一样的New函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewStore</span><span class="params">(keyFunc KeyFunc)</span></span> Store &#123;</span><br><span class="line">   <span class="keyword">return</span> &amp;cache&#123;</span><br><span class="line">      cacheStorage: NewThreadSafeStore(Indexers&#123;&#125;, Indices&#123;&#125;),</span><br><span class="line">      keyFunc:      keyFunc,</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewIndexer</span><span class="params">(keyFunc KeyFunc, indexers Indexers)</span></span> Indexer &#123;</span><br><span class="line">   <span class="keyword">return</span> &amp;cache&#123;</span><br><span class="line">      cacheStorage: NewThreadSafeStore(indexers, Indices&#123;&#125;),</span><br><span class="line">      keyFunc:      keyFunc,</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ThreadSafeStore"><a href="#ThreadSafeStore" class="headerlink" title="ThreadSafeStore"></a>ThreadSafeStore</h3><p>ThreadSafeStore是Indexer的核心逻辑所在，Indexer的多数方法是直接调用内部cacheStorage属性的方法实现的，同样先看接口定义：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ThreadSafeStore <span class="keyword">interface</span> &#123;</span><br><span class="line">   Add(key <span class="type">string</span>, obj <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">   Update(key <span class="type">string</span>, obj <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">   Delete(key <span class="type">string</span>)</span><br><span class="line">   Get(key <span class="type">string</span>) (item <span class="keyword">interface</span>&#123;&#125;, exists <span class="type">bool</span>)</span><br><span class="line">   List() []<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">   ListKeys() []<span class="type">string</span></span><br><span class="line">   Replace(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;, <span class="type">string</span>)</span><br><span class="line">   Index(indexName <span class="type">string</span>, obj <span class="keyword">interface</span>&#123;&#125;) ([]<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>)</span><br><span class="line">   IndexKeys(indexName, indexKey <span class="type">string</span>) ([]<span class="type">string</span>, <span class="type">error</span>)</span><br><span class="line">   ListIndexFuncValues(name <span class="type">string</span>) []<span class="type">string</span></span><br><span class="line">   ByIndex(indexName, indexKey <span class="type">string</span>) ([]<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>)</span><br><span class="line">   GetIndexers() Indexers</span><br><span class="line">   AddIndexers(newIndexers Indexers) <span class="type">error</span></span><br><span class="line">   Resync() <span class="type">error</span> <span class="comment">// 过期了，没有具体代码逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对应实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> threadSafeMap <span class="keyword">struct</span> &#123;</span><br><span class="line">   lock  sync.RWMutex</span><br><span class="line">   items <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">   indexers Indexers</span><br><span class="line">   indices Indices</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的Indexers和Indices是：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Index <span class="keyword">map</span>[<span class="type">string</span>]sets.String</span><br><span class="line"><span class="keyword">type</span> Indexers <span class="keyword">map</span>[<span class="type">string</span>]IndexFunc</span><br><span class="line"><span class="keyword">type</span> Indices <span class="keyword">map</span>[<span class="type">string</span>]Index</span><br></pre></td></tr></table></figure>

<p>Indexers 里存的是 Index 函数 map，一个典型的实现是字符串 namespace 作为 key，IndexFunc 类型的实现 <code>MetaNamespaceIndexFunc</code> 函数作为 value，也就是我们希望通过 namespace 来检索时，通过 Indexers 可以拿到对应的计算 Index 的函数，接着拿着这个函数，把对象穿进去，就可以计算出这个对象对应的 key，在这里也就是具体的 namespace 值，比如 default、kube-system 这种。然后在 Indices 里存的也是一个 map，key 是上面计算出来的 default 这种 namespace 值，value 是一个 set，而 set 表示的是这个 default namespace 下的一些具体 pod 的 <code>&lt;namespace&gt;/&lt;name&gt;</code> 这类字符串。最后拿着这种 key，就可以在 items 里检索到对应的对象了。</p>
<p>![image-20231110114758819](&#x2F;Users&#x2F;goiruri&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20231110114758819.png)</p>
<h3 id="总结一下-1"><a href="#总结一下-1" class="headerlink" title="总结一下"></a>总结一下</h3><p>Indexer是Informer实现本地缓存的关键模块。作为Indexer的主要实现，<code>cache</code>是一个存储在内存中的缓存器，初始化时，会指定<code>keyFunc</code>，通常会根据对象的资源名与对象名组合成一个唯一的字符串作为对象键。此外，<code>cache</code>将缓存的维护工作委托给<code>threadSafeMap</code>来完成，<code>threadSafeMap</code>内部实现了一套类似MySql覆盖索引、二级索引的存储机制，用户可以自行添加具有特定索引生成方法的二级索引，方便自己的数据存取。</p>
<h2 id="DeltaFIFO"><a href="#DeltaFIFO" class="headerlink" title="DeltaFIFO"></a>DeltaFIFO</h2><p>DeltaFIFO其实是两个词：Delta+FIFO，Delta表示变化，FIFO则是先入先出的队列。</p>
<p>![image-20231110143712545](&#x2F;Users&#x2F;goiruri&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20231110143712545.png)</p>
<p>DeltaFIFO将接收来的资源event转化为特定的变化类型，存储在队列中，周期性的POP出去，分发到事件处理器，并更新Indexer中的本地缓存。</p>
<p>Client-go定义了以下几种变化类型：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件路径： k8s.io/client-go/tools/cache/delta_fifo.go</span></span><br><span class="line"><span class="comment">// DeltaType 其实是字符串类型的别名，代表一种变化</span></span><br><span class="line"><span class="keyword">type</span> DeltaType <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Change type definition</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Added   DeltaType = &amp;quot;Added&amp;quot; <span class="comment">// 增</span></span><br><span class="line">    Updated DeltaType = &amp;quot;Updated&amp;quot; <span class="comment">// 更新</span></span><br><span class="line">    Deleted DeltaType = &amp;quot;Deleted&amp;quot;  <span class="comment">// 删除</span></span><br><span class="line">    Replaced DeltaType = &amp;quot;Replaced&amp;quot; <span class="comment">// 替换，list出错时，会触发relist，此时会替换</span></span><br><span class="line">    Sync DeltaType = &amp;quot;Sync&amp;quot;  <span class="comment">// 周期性的同步，底层会当作一个update类型处理</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// Delta由一个对象+类型组成</span></span><br><span class="line"><span class="keyword">type</span> Delta <span class="keyword">struct</span> &#123;</span><br><span class="line">    Type   DeltaType</span><br><span class="line">    Object <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Deltas是一组Delta</span></span><br><span class="line"><span class="keyword">type</span> Deltas []Delta</span><br></pre></td></tr></table></figure>

<p>然后看一下Delta_FIFO的实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件路径： k8s.io/client-go/tools/cache/delta_fifo.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DeltaFIFO <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 读写锁与条件变量</span></span><br><span class="line">    lock sync.RWMutex</span><br><span class="line">    cond sync.Cond</span><br><span class="line"></span><br><span class="line">    <span class="comment">// items是一个字典，存储了对象键与Delats的映射关系</span></span><br><span class="line">    <span class="comment">// queue是一个FIFO队列，存储了先后进入队列的对象的对象键，queue里面的对象和items里的对象键是一一对应的</span></span><br><span class="line">    <span class="comment">// items里的对象，至少有一个Delta</span></span><br><span class="line">    items <span class="keyword">map</span>[<span class="type">string</span>]Deltas</span><br><span class="line">    queue []<span class="type">string</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过Replace()接口将第一批对象放入队列，或者第一次调用增、删、改接口时标记为true</span></span><br><span class="line">    populated <span class="type">bool</span></span><br><span class="line">    <span class="comment">// 通过Replace()接口将第一批对象放入队列的对象数量</span></span><br><span class="line">    initialPopulationCount <span class="type">int</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于计算对象键的方法</span></span><br><span class="line">    keyFunc KeyFunc</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其实就是Indexer</span></span><br><span class="line">    knownObjects KeyListerGetter</span><br><span class="line"></span><br><span class="line">    <span class="comment">// emitDeltaTypeReplaced is whether to emit the Replaced or Sync</span></span><br><span class="line">    <span class="comment">// DeltaType when Replace() is called (to preserve backwards compat).</span></span><br><span class="line">    emitDeltaTypeReplaced <span class="type">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以用一张图简单描述下Delta_FIFO里面items和queue的关系：</p>
<p>![image-20231110144144459](&#x2F;Users&#x2F;goiruri&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20231110144144459.png)</p>
<p>采用这样的结构把对象与事件的存储分离，好处就是不会因为某个对象的事件太多，而导致其他对象的事件一直得不到消费。</p>
<p>Delta_FIFO的核心操作有两个：往队列里面添加元素、从队列中POP元素，可以看下这两个方法的实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件路径： k8s.io/client-go/tools/cache/delta_fifo.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// queueActionLocked 用于向队列中添加delta,调用前必须加写锁 </span></span><br><span class="line"><span class="comment">// 传入delta类型、资源对象两个参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *DeltaFIFO)</span></span> queueActionLocked(actionType DeltaType, obj <span class="keyword">interface</span>&#123;&#125;) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// 获取资源对象的对象键</span></span><br><span class="line">    id, err := f.KeyOf(obj)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> KeyError&#123;obj, err&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向items中添加delta，并对操作进行去重，目前来看，只有连续两次操作都是删除操作的情况下，才可以合并，其他操作不会合并</span></span><br><span class="line">    newDeltas := <span class="built_in">append</span>(f.items[id], Delta&#123;actionType, obj&#125;)</span><br><span class="line">    newDeltas = dedupDeltas(newDeltas)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(newDeltas) &amp;gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 向queue和items中添加元素</span></span><br><span class="line">        <span class="comment">// 添加以后，条件变量发出消息，通知可能正在阻塞的POP方法有事件进队列了</span></span><br><span class="line">        <span class="keyword">if</span> _, exists := f.items[id]; !exists &#123;</span><br><span class="line">            f.queue = <span class="built_in">append</span>(f.queue, id)</span><br><span class="line">        &#125;</span><br><span class="line">        f.items[id] = newDeltas</span><br><span class="line">        f.cond.Broadcast()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 冗余判断，其实是不会走到这个分支的，去重后的delta list长度怎么也不可能小于1</span></span><br><span class="line">        <span class="built_in">delete</span>(f.items, id)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pop方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *DeltaFIFO)</span></span> Pop(process PopProcessFunc) (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>) &#123;</span><br><span class="line">    f.lock.Lock()</span><br><span class="line">    <span class="keyword">defer</span> f.lock.Unlock()</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 如果队列是空的，利用条件变量阻塞住，直到有新的delta</span></span><br><span class="line">        <span class="comment">// 如果Close()被调用，则退出</span></span><br><span class="line">        <span class="comment">// 否则一直循环处理</span></span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">len</span>(f.queue) == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> f.closed &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span>, ErrFIFOClosed</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            f.cond.Wait()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 取队列第一个的所有deltas</span></span><br><span class="line">        id := f.queue[<span class="number">0</span>]</span><br><span class="line">        f.queue = f.queue[<span class="number">1</span>:]</span><br><span class="line">        <span class="keyword">if</span> f.initialPopulationCount &amp;gt; <span class="number">0</span> &#123;</span><br><span class="line">            f.initialPopulationCount--</span><br><span class="line">        &#125;</span><br><span class="line">        item, ok := f.items[id]</span><br><span class="line">        <span class="keyword">if</span> !ok &#123;</span><br><span class="line">            <span class="comment">// Item may have been deleted subsequently.</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">delete</span>(f.items, id)</span><br><span class="line">        err := process(item)</span><br><span class="line">        <span class="comment">// 如果处理失败了，调用addIfNotPresent，addIfNotPresent意为：如果queue中没有则添加</span></span><br><span class="line">        <span class="comment">// 本身刚刚从queue和items中取出对象，应该不会存在重复的对象，这里调用addIfNotPresent应该只是为了保险起见</span></span><br><span class="line">        <span class="keyword">if</span> e, ok := err.(ErrRequeue); ok &#123;</span><br><span class="line">            f.addIfNotPresent(id, item)</span><br><span class="line">            err = e.Err</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> item, err</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Reflector"><a href="#Reflector" class="headerlink" title="Reflector"></a>Reflector</h2><p>K8s的设计是事件驱动的、充分微服务化的，我们可以从事件传递的角度重新理解一下K8s:</p>
<p>组件之间互相看作是事件的生产者、消费者，API Server看作是一个只用内存存储事件的Broker,我们可以从消息队列的角度取理解一下，如下图展示的：</p>
<p>![image-20231110145802473](&#x2F;Users&#x2F;goiruri&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20231110145802473.png)</p>
<p>k8s服务端通过读取etcd的资源变更信息，向所有客户端发布资源变更事件。k8s中，组件之间通过HTTP协议进行通信，在不额外引入其他中间件的情况下，保证消息传递的实时性、可靠性、顺序性不是一个容易的事情。K8s内部所有的组件都是通过Informer机制实现与API Server的通信的。Informer直译就是消息通知者的意思。</p>
<p>通常一个Informer只会关注一种特定的资源，Reflector负责从API Server拉取&amp;同步该资源类型下所有对象的event。例如，如果当前informer关注Pod资源，那么Reflector会首先list集群中所有的Pod的信息，同步本地的ResourceVersion，之后基于当前的ResourceVerison，使用一个Http长连接Watch集群中Pod资源的事件，并传递到Delta_FIFO模块。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件路径： k8s.io/client-go/tools/cache/reflector.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Reflector监控某一种资源的变化，并将这些变化传递到存储中</span></span><br><span class="line"><span class="keyword">type</span> Reflector <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span> <span class="comment">// 名字，默认会被命名为 文件：行号 </span></span><br><span class="line">    expectedTypeName <span class="type">string</span>   <span class="comment">// 被监控的资源的类型名</span></span><br><span class="line">    expectedType reflect.Type  <span class="comment">// 监控的对象类型</span></span><br><span class="line">    expectedGVK *schema.GroupVersionKind  <span class="comment">// The GVK of the object we expect to place in the store if unstructured.</span></span><br><span class="line">    store Store <span class="comment">// 存储，就是Delta_FIFO,这里的Store类型实际是Delta_FIFO的父类</span></span><br><span class="line">    listerWatcher ListerWatcher <span class="comment">// 用来进行list&amp;amp;watch的接口对象,大概知道做什么的就行了，底层是通过http长连接实现的资源监听</span></span><br><span class="line"></span><br><span class="line">    resyncPeriod time.Duration <span class="comment">// 重新同步的周期</span></span><br><span class="line">    ShouldResync <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">bool</span>  <span class="comment">// 周期性的判断是否需要重新同步</span></span><br><span class="line">    clock clock.Clock   <span class="comment">// 时钟对象，主要是为了给测试留后门，方便修改时间</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ResourceVersion是ETCD生成的全局唯一且递增的序号，通过此序号，客户端可以知道目前与服务端信息同步的状态，每次只取大于等于本地ResourceVersion的事件，好处是可以实现事件的全局唯一，实现“断点续传”功能，不用担心本地客户端偶尔出现的网络异常。</p>
<p>可以关注到<code>Reflector</code>三个比较关键的方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件路径： k8s.io/client-go/tools/cache/reflector.go </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 反射器的入口方法，wait.Backoffutil会周期性的执行传入的匿名函数，直到接收到stopCh传来的终止信号</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reflector)</span></span> Run(stopCh &amp;lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;) &#123;</span><br><span class="line">    klog.V(<span class="number">2</span>).Infof(&amp;quot;Starting reflector %s (%s) from %s&amp;quot;, r.expectedTypeName, r.resyncPeriod, r.name)</span><br><span class="line">    wait.BackoffUntil(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err := r.ListAndWatch(stopCh); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            r.watchErrorHandler(r, err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, r.backoffManager, <span class="literal">true</span>, stopCh)</span><br><span class="line">    klog.V(<span class="number">2</span>).Infof(&amp;quot;Stopping reflector %s (%s) from %s&amp;quot;, r.expectedTypeName, r.resyncPeriod, r.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ListAndWatch方法比较长，这里截取部分展示,主要有三部分</span></span><br><span class="line"><span class="comment">// 1. list操作，更新本地的资源版本号，最先执行且只执行一次</span></span><br><span class="line"><span class="comment">// 2. 启动后台的周期性sync协程</span></span><br><span class="line"><span class="comment">// 3. 死循环执行watchHandler操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reflector)</span></span> ListAndWatch(stopCh &amp;lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// 全量list的逻辑，只执行一次</span></span><br><span class="line">    <span class="comment">// 这一步里面会将list返回的结果实例化为对象数组，也就是反射的过程，这也是reflector名字的由来，但是reflector目前做的不仅仅是反射</span></span><br><span class="line">    <span class="keyword">if</span> err := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        r.setIsLastSyncResourceVersionUnavailable(<span class="literal">false</span>) <span class="comment">// list was successful</span></span><br><span class="line">        initTrace.Step(&amp;quot;Objects listed&amp;quot;)</span><br><span class="line">        listMetaInterface, err := meta.ListAccessor(list)</span><br><span class="line">        r.setLastSyncResourceVersion(resourceVersion)</span><br><span class="line">        initTrace.Step(&amp;quot;Resource version updated&amp;quot;)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 后台定期sync协程，会一直周期性执行</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        resyncCh, cleanup := r.resyncChan()</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">            cleanup()</span><br><span class="line">            resyncCh, cleanup = r.resyncChan()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// watch操作</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> err := r.watchHandler(start, w, &amp;amp;resourceVersion, resyncerrc, stopCh); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 我们继续看看watchHandler里面做了什么</span></span><br><span class="line"><span class="comment">// 去掉了注释、日志、错误判断，只看核心逻辑，可以直观的看到，最后的处理逻辑落在了Delta_FIFO上</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reflector)</span></span> watchHandler(start time.Time, w watch.Interface, resourceVersion *<span class="type">string</span>, errc <span class="keyword">chan</span> <span class="type">error</span>, stopCh &amp;lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;) <span class="type">error</span> &#123;</span><br><span class="line">    eventCount := <span class="number">0</span></span><br><span class="line">    <span class="keyword">defer</span> w.Stop()</span><br><span class="line">loop:</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &amp;lt;-stopCh:</span><br><span class="line">            <span class="keyword">return</span> errorStopRequested</span><br><span class="line">        <span class="keyword">case</span> err := &amp;lt;-errc:</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        <span class="keyword">case</span> event, ok := &amp;lt;-w.ResultChan():</span><br><span class="line">            <span class="keyword">if</span> !ok &#123;</span><br><span class="line">                <span class="keyword">break</span> loop</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> event.Type == watch.Error &#123;</span><br><span class="line">                <span class="keyword">return</span> apierrors.FromObject(event.Object)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            meta, err := meta.Accessor(event.Object)</span><br><span class="line">            newResourceVersion := meta.GetResourceVersion()</span><br><span class="line">            <span class="comment">// 操作Delta_FIFO</span></span><br><span class="line">            <span class="keyword">switch</span> event.Type &#123;</span><br><span class="line">            <span class="keyword">case</span> watch.Added:</span><br><span class="line">                err := r.store.Add(event.Object)</span><br><span class="line">            <span class="keyword">case</span> watch.Modified:</span><br><span class="line">                err := r.store.Update(event.Object)</span><br><span class="line">            <span class="keyword">case</span> watch.Deleted:</span><br><span class="line">                err := r.store.Delete(event.Object)</span><br><span class="line">            <span class="keyword">case</span> watch.Bookmark:</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                utilruntime.HandleError(fmt.Errorf(&amp;quot;%s: unable to understand watch event %#v&amp;quot;, r.name, event))</span><br><span class="line">            &#125;</span><br><span class="line">            *resourceVersion = newResourceVersion</span><br><span class="line">            r.setLastSyncResourceVersion(newResourceVersion)</span><br><span class="line">            eventCount++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结一下-2"><a href="#总结一下-2" class="headerlink" title="总结一下"></a>总结一下</h3><ol>
<li>Reflector利用apiserver的client列举全量对象(版本为0以后的对象全部列举出来)</li>
<li>将全量对象同步到DeltaFIFO中，并且更新资源的版本号，后续watch会依赖此版本号；</li>
<li>在后台启动一个定时resync的协程，把全量对象以Update事件的方式通知出去(如果没有设置同步周期，这一步可以不执行)；</li>
<li>基于当前资源版本号watch资源;</li>
<li>一旦有对象发生变化，那么就会根据变化的类型(新增、更新、删除)调用DeltaFIFO的相应接口，同时更新当前资源的版本号</li>
</ol>
<h2 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h2><h2 id="流程解析"><a href="#流程解析" class="headerlink" title="流程解析"></a>流程解析</h2><p>reflector会持续监听k8s集群中指定资源类型的API，当发现变动和更新时，就会创建一个发生变动的对象的副本，并将其添加到队列DeltaFIFO中。</p>
<p>Indexer保存了来自apiServer的资源。使用listWatch方式来维护资源的增量变化。通过这种方式可以减小对apiServer的访问，减轻apiServer端的压力。</p>
<p>Indexer的接口如下，它继承了Store接口，Store中定义了对对象的增删改查等方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// client-go/tools/cache/index.go</span></span><br><span class="line"><span class="keyword">type</span> Indexer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Store</span><br><span class="line">    <span class="comment">// Retrieve list of objects that match on the named indexing function</span></span><br><span class="line">    Index(indexName <span class="type">string</span>, obj <span class="keyword">interface</span>&#123;&#125;) ([]<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>)</span><br><span class="line">    <span class="comment">// IndexKeys returns the set of keys that match on the named indexing function.</span></span><br><span class="line">    IndexKeys(indexName, indexKey <span class="type">string</span>) ([]<span class="type">string</span>, <span class="type">error</span>)</span><br><span class="line">    <span class="comment">// ListIndexFuncValues returns the list of generated values of an Index func</span></span><br><span class="line">    ListIndexFuncValues(indexName <span class="type">string</span>) []<span class="type">string</span></span><br><span class="line">    <span class="comment">// ByIndex lists object that match on the named indexing function with the exact key</span></span><br><span class="line">    ByIndex(indexName, indexKey <span class="type">string</span>) ([]<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>)</span><br><span class="line">    <span class="comment">// GetIndexer return the indexers</span></span><br><span class="line">    GetIndexers() Indexers</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AddIndexers adds more indexers to this store.  If you call this after you already have data</span></span><br><span class="line">    <span class="comment">// in the store, the results are undefined.</span></span><br><span class="line">    AddIndexers(newIndexers Indexers) <span class="type">error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// client-go/tools/cache/store.go</span></span><br><span class="line"><span class="keyword">type</span> Store <span class="keyword">interface</span> &#123;</span><br><span class="line">    Add(obj <span class="keyword">interface</span>&#123;&#125;) <span class="type">error</span></span><br><span class="line">    Update(obj <span class="keyword">interface</span>&#123;&#125;) <span class="type">error</span></span><br><span class="line">    Delete(obj <span class="keyword">interface</span>&#123;&#125;) <span class="type">error</span></span><br><span class="line">    List() []<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    ListKeys() []<span class="type">string</span></span><br><span class="line">    Get(obj <span class="keyword">interface</span>&#123;&#125;) (item <span class="keyword">interface</span>&#123;&#125;, exists <span class="type">bool</span>, err <span class="type">error</span>)</span><br><span class="line">    GetByKey(key <span class="type">string</span>) (item <span class="keyword">interface</span>&#123;&#125;, exists <span class="type">bool</span>, err <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Replace will delete the contents of the store, using instead the</span></span><br><span class="line">    <span class="comment">// given list. Store takes ownership of the list, you should not reference</span></span><br><span class="line">    <span class="comment">// it after calling this function.</span></span><br><span class="line">    Replace([]<span class="keyword">interface</span>&#123;&#125;, <span class="type">string</span>) <span class="type">error</span></span><br><span class="line">    Resync() <span class="type">error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>cache实现了Indexer接口，但cache是包内私有的(首字母小写)，只能通过包内封装的函数进行调用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// client-go/tools/cache/store.go</span></span><br><span class="line"><span class="keyword">type</span> cache <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// cacheStorage bears the burden of thread safety for the cache</span></span><br><span class="line">    cacheStorage ThreadSafeStore</span><br><span class="line">    <span class="comment">// keyFunc is used to make the key for objects stored in and retrieved from items, and</span></span><br><span class="line">    <span class="comment">// should be deterministic.</span></span><br><span class="line">    keyFunc KeyFunc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// client-go/tools/cache/thread_safe_store.go</span></span><br><span class="line"><span class="keyword">type</span> ThreadSafeStore <span class="keyword">interface</span> &#123;</span><br><span class="line">    Add(key <span class="type">string</span>, obj <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">    Update(key <span class="type">string</span>, obj <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">    Delete(key <span class="type">string</span>)</span><br><span class="line">    Get(key <span class="type">string</span>) (item <span class="keyword">interface</span>&#123;&#125;, exists <span class="type">bool</span>)</span><br><span class="line">    List() []<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    ListKeys() []<span class="type">string</span></span><br><span class="line">    Replace(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;, <span class="type">string</span>)</span><br><span class="line">    Index(indexName <span class="type">string</span>, obj <span class="keyword">interface</span>&#123;&#125;) ([]<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>)</span><br><span class="line">    IndexKeys(indexName, indexKey <span class="type">string</span>) ([]<span class="type">string</span>, <span class="type">error</span>)</span><br><span class="line">    ListIndexFuncValues(name <span class="type">string</span>) []<span class="type">string</span></span><br><span class="line">    ByIndex(indexName, indexKey <span class="type">string</span>) ([]<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>)</span><br><span class="line">    GetIndexers() Indexers</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AddIndexers adds more indexers to this store.  If you call this after you already have data</span></span><br><span class="line">    <span class="comment">// in the store, the results are undefined.</span></span><br><span class="line">    AddIndexers(newIndexers Indexers) <span class="type">error</span></span><br><span class="line">    Resync() <span class="type">error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以通过NewStore和NewIndexer初始化cache来返回一个Store或Indexer指针(cache实现了Store和Indexer接口)。NewStore和NewIndexer返回的Store和Indexer接口的数据载体为threadSafeMap，threadSafeMap通过NewThreadSafeStore函数初始化。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// client-go/tools/cache/store.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cache)</span></span> Add(obj <span class="keyword">interface</span>&#123;&#125;) <span class="type">error</span> &#123;</span><br><span class="line">    key, err := c.keyFunc(obj)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> KeyError&#123;obj, err&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    c.cacheStorage.Add(key, obj)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// client-go/tools/cache/store.go</span></span><br><span class="line"><span class="comment">// NewStore returns a Store implemented simply with a map and a lock.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewStore</span><span class="params">(keyFunc KeyFunc)</span></span> Store &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;cache&#123;</span><br><span class="line">        cacheStorage: NewThreadSafeStore(Indexers&#123;&#125;, Indices&#123;&#125;),</span><br><span class="line">        keyFunc:      keyFunc,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewIndexer returns an Indexer implemented simply with a map and a lock.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewIndexer</span><span class="params">(keyFunc KeyFunc, indexers Indexers)</span></span> Indexer &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;cache&#123;</span><br><span class="line">        cacheStorage: NewThreadSafeStore(indexers, Indices&#123;&#125;),</span><br><span class="line">        keyFunc:      keyFunc,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>client-go中的很多实现封装都非常规范，index.go中给出了索引相关的操作(接口)；store.go中给出了与操作存储相关的接口，并提供了一个cache实现，当然也可以实现自行实现Store接口；thread_safe_store.go为cache的私有实现。</p>
<p>client-go的indexer实际操作的还是threadSafeMap中的方法和数据，调用关系如下：</p>
<p>![image-20231109145326413](&#x2F;Users&#x2F;goiruri&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20231109145326413.png)</p>
<p>可以通过下图理解threadSafeMap中各种索引之间的关系</p>
<p>![image-20231109150211829](&#x2F;Users&#x2F;goiruri&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20231109150211829.png)</p>
<ul>
<li>indexer实际的对象存储在threadSafeMap结构中</li>
<li>indexers划分了不同的索引类型(indexName，如namespace)，并按照索引类型进行索引(indexFunc，如MetaNamespaceIndexFunc)，得出符合该对象的索引键(indexKeys，如namespaces)，一个对象在一个索引类型中可能有多个索引键。</li>
<li>indices按照索引类型保存了索引(index，如包含所有namespaces下面的obj)，进而可以按照索引键找出特定的对象键(keys，如某个namespace下面的对象键)，indices用于快速查找对象</li>
<li>items按照对象键保存了实际的对象</li>
</ul>
<p>以namespace作为索引类型为例来讲，首先从indexers获取计算namespace的indexFunc，然后使用该indexFunc计算出与入参对象相关的所有namespaces。indices中保存了所有namespaces下面的对象键，可以获取特定namespace下面的所有对象键，在items中输入特定的对象键就可以得出特定的对象。indexers用于找出与特定对象相关的资源，如找出某Pod相关的secrets。</p>
<p>默认的indexFunc如下，根据对象的namespace进行分类</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// client-go/tools/cache/index.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MetaNamespaceIndexFunc</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span></span> ([]<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    meta, err := meta.Accessor(obj)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> []<span class="type">string</span>&#123;<span class="string">&quot;&quot;</span>&#125;, fmt.Errorf(<span class="string">&quot;object has no meta: %v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> []<span class="type">string</span>&#123;meta.GetNamespace()&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>cache结构中的keyFunc用于生成objectKey，下面是默认的keyFunc。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//client-go/tools/cache/thread_safe_store.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MetaNamespaceKeyFunc</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span></span> (<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> key, ok := obj.(ExplicitKey); ok &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">string</span>(key), <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    meta, err := meta.Accessor(obj)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>, fmt.Errorf(<span class="string">&quot;object has no meta: %v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(meta.GetNamespace()) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> meta.GetNamespace() + <span class="string">&quot;/&quot;</span> + meta.GetName(), <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> meta.GetName(), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">igl1t</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/02/04/client-go%E5%8E%9F%E7%90%86/">http://example.com/2025/02/04/client-go%E5%8E%9F%E7%90%86/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">igl1t's blog</a>！</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/02/04/%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%99%A8%E5%8E%9F%E7%90%86%E5%8F%8AGMP%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/" title="Golang的协程调度器原理及GMP设计思想"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Golang的协程调度器原理及GMP设计思想</div></div><div class="info-2"><div class="info-item-1">Golang的协程调度器原理及GMP设计思想一、Golang“调度器”的由来？(1)...</div></div></div></a><a class="pagination-related" href="/2025/02/04/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/" title="面向对象设计原则"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">面向对象设计原则</div></div><div class="info-2"><div class="info-item-1">对于面向对象软件系统的设计而言，在支持可维护性的同时，提高系统的可复用性是一个至关重要的问题，**如何同时提高一个软件系统的可维护性和可复用性是面向对象设计需要解决的核心问题之一。**在面向对象设计中，可维护性的复用是以设计原则为基础的。每一个原则都蕴含一些面向对象设计的思想，可以从不同的角度提升一个软件结构的设计水平。 **面向对象设计原则为支持可维护性复用而诞生，这些原则蕴含在很多设计模式中，它们是从许多设计方案中总结出的指导性原则。**面向对象设计原则也是我们用于评价一个设计模式的使用效果的重要指标之一。 原则的目的： 高内聚，低耦合 面向对象设计原则表 1，单一职责原则类的职责单一，对外只提供一种功能，而引起类变化的原因都应该只有一个。 12345678910111213141516171819202122232425package mainimport &quot;fmt&quot;type ClothesShop struct &#123;&#125;func (cs *ClothesShop) OnShop()...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">igl1t</div><div class="author-info-description">某不知名黑客</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">13</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#client-go%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">client-go简介</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#client-go%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="toc-number">2.</span> <span class="toc-text">client-go目录结构</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B"><span class="toc-number">3.</span> <span class="toc-text">流程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ClientSet"><span class="toc-number">3.1.</span> <span class="toc-text">ClientSet</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DynamicClient"><span class="toc-number">3.2.</span> <span class="toc-text">DynamicClient</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DiscoveryClient"><span class="toc-number">3.3.</span> <span class="toc-text">DiscoveryClient</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E4%B8%80%E4%B8%8B"><span class="toc-number">3.4.</span> <span class="toc-text">总结一下</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#client-go%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86"><span class="toc-number">4.</span> <span class="toc-text">client-go内部原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%84%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D"><span class="toc-number">4.1.</span> <span class="toc-text">各组件介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B-1"><span class="toc-number">4.2.</span> <span class="toc-text">流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Indexer"><span class="toc-number">4.3.</span> <span class="toc-text">Indexer</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Indexer%E6%8E%A5%E5%8F%A3"><span class="toc-number">4.3.1.</span> <span class="toc-text">Indexer接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadSafeStore"><span class="toc-number">4.3.2.</span> <span class="toc-text">ThreadSafeStore</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E4%B8%80%E4%B8%8B-1"><span class="toc-number">4.3.3.</span> <span class="toc-text">总结一下</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DeltaFIFO"><span class="toc-number">4.4.</span> <span class="toc-text">DeltaFIFO</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Reflector"><span class="toc-number">4.5.</span> <span class="toc-text">Reflector</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E4%B8%80%E4%B8%8B-2"><span class="toc-number">4.5.1.</span> <span class="toc-text">总结一下</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Controller"><span class="toc-number">4.6.</span> <span class="toc-text">Controller</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90"><span class="toc-number">4.7.</span> <span class="toc-text">流程解析</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/04/channel/" title="channel使用">channel使用</a><time datetime="2025-02-04T12:52:00.038Z" title="发表于 2025-02-04 20:52:00">2025-02-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/04/yaml%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/" title="yaml文件详解">yaml文件详解</a><time datetime="2025-02-04T12:52:00.035Z" title="发表于 2025-02-04 20:52:00">2025-02-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/04/SingleFlight/" title="SingleFlight">SingleFlight</a><time datetime="2025-02-04T12:52:00.034Z" title="发表于 2025-02-04 20:52:00">2025-02-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/04/vim%E6%89%93%E9%80%A0%E6%88%90idea/" title="vim打造成ide">vim打造成ide</a><time datetime="2025-02-04T12:52:00.033Z" title="发表于 2025-02-04 20:52:00">2025-02-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/04/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/" title="io 多路复用">io 多路复用</a><time datetime="2025-02-04T12:52:00.031Z" title="发表于 2025-02-04 20:52:00">2025-02-04</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By igl1t</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>